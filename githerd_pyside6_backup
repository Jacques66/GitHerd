#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GitHerd â€” Real-time Git branch synchronizer (PySide6 version)

Keeps multiple Git branches aligned in real-time.
Ideal for parallel AI coding sessions (Claude Code, Cursor, etc.)
or any workflow with multiple active branches.

Copyright (c) 2026 InZeMobile
Licensed under the MIT License. See LICENSE file for details.

https://github.com/Jacques66/GitHerd
"""

import subprocess
import threading
import time
import sys
import os
import json
from pathlib import Path
from datetime import datetime

from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QLabel, QPushButton, QTextEdit, QTabWidget, QTabBar, QFrame,
    QMenuBar, QMenu, QFileDialog, QMessageBox, QDialog,
    QFormLayout, QLineEdit, QSpinBox, QDoubleSpinBox, QCheckBox,
    QSizePolicy
)
from PySide6.QtCore import Qt, QTimer, Signal, QObject
from PySide6.QtGui import QFont, QAction, QShortcut, QKeySequence, QColor

# ============================================================
# CONFIG & PERSISTENCE
# ============================================================

CONFIG_DIR = Path.home() / ".config" / "githerd"
REPOS_FILE = CONFIG_DIR / "repos.json"
SETTINGS_FILE = CONFIG_DIR / "settings.json"

DEFAULT_GLOBAL_SETTINGS = {
    "git_binary": "git",
    "font_zoom": 1.4,
    "auto_start_polling": False,
    "compact_mode": False,
    "desktop_notifications": True
}

DEFAULT_REPO_CONFIG = {
    "remote": "origin",
    "main_branch": "main",
    "branch_prefix": "claude/",
    "interval_seconds": 60
}

try:
    import tomllib
except ModuleNotFoundError:
    import tomli as tomllib


def load_global_settings():
    """Charge les settings globaux."""
    if SETTINGS_FILE.exists():
        try:
            with open(SETTINGS_FILE, "r") as f:
                data = json.load(f)
                settings = DEFAULT_GLOBAL_SETTINGS.copy()
                settings.update(data)
                return settings
        except Exception:
            pass
    return DEFAULT_GLOBAL_SETTINGS.copy()


def save_global_settings(settings):
    """Sauvegarde les settings globaux."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    with open(SETTINGS_FILE, "w") as f:
        json.dump(settings, f, indent=2)


def load_repo_config(repo_path):
    """Charge la config depuis githerd.toml du repo, ou utilise les valeurs par dÃ©faut."""
    config_file = Path(repo_path) / "githerd.toml"
    if config_file.exists():
        try:
            cfg = tomllib.load(open(config_file, "rb"))
            return {
                "remote": cfg.get("git", {}).get("remote", DEFAULT_REPO_CONFIG["remote"]),
                "main_branch": cfg.get("git", {}).get("main_branch", DEFAULT_REPO_CONFIG["main_branch"]),
                "branch_prefix": cfg.get("git", {}).get("branch_prefix", DEFAULT_REPO_CONFIG["branch_prefix"]),
                "interval_seconds": cfg.get("sync", {}).get("interval_seconds", DEFAULT_REPO_CONFIG["interval_seconds"])
            }
        except Exception:
            pass
    return DEFAULT_REPO_CONFIG.copy()


def save_repo_config(repo_path, config):
    """Sauvegarde la config dans githerd.toml du repo."""
    config_file = Path(repo_path) / "githerd.toml"
    toml_content = f'''[git]
remote = "{config['remote']}"
main_branch = "{config['main_branch']}"
branch_prefix = "{config['branch_prefix']}"

[sync]
interval_seconds = {config['interval_seconds']}
'''
    with open(config_file, "w") as f:
        f.write(toml_content)


def load_saved_repos():
    """Charge la liste des repos sauvegardÃ©s."""
    if REPOS_FILE.exists():
        try:
            with open(REPOS_FILE, "r") as f:
                data = json.load(f)
                return data.get("repos", [])
        except Exception:
            pass
    return []


def save_repos(repos):
    """Sauvegarde la liste des repos."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    with open(REPOS_FILE, "w") as f:
        json.dump({"repos": repos}, f, indent=2)


def detect_repo_settings(repo_path, git_binary="git"):
    """DÃ©tecte automatiquement remote et main_branch du repo."""
    settings = DEFAULT_REPO_CONFIG.copy()

    code, out, _ = run_git([git_binary, "remote"], cwd=repo_path)
    if code == 0 and out:
        remotes = out.splitlines()
        if remotes:
            settings["remote"] = remotes[0]

    remote = settings["remote"]
    code, out, _ = run_git(
        [git_binary, "symbolic-ref", f"refs/remotes/{remote}/HEAD"],
        cwd=repo_path
    )
    if code == 0 and out:
        parts = out.split("/")
        if len(parts) >= 4:
            settings["main_branch"] = parts[-1]
    else:
        code, out, _ = run_git(
            [git_binary, "branch", "-r", "--list", f"{remote}/main"],
            cwd=repo_path
        )
        if code == 0 and out.strip():
            settings["main_branch"] = "main"
        else:
            code, out, _ = run_git(
                [git_binary, "branch", "-r", "--list", f"{remote}/master"],
                cwd=repo_path
            )
            if code == 0 and out.strip():
                settings["main_branch"] = "master"

    return settings


# ============================================================
# GIT HELPERS
# ============================================================

def run_git(cmd, cwd=None):
    try:
        p = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            cwd=cwd,
            timeout=30
        )
        return p.returncode, p.stdout.strip(), p.stderr.strip()
    except subprocess.TimeoutExpired:
        return 1, "", "Timeout"
    except FileNotFoundError:
        return 1, "", f"Command not found: {cmd[0]}"
    except Exception as e:
        return 1, "", str(e)


def commits_ahead(base, tip, cwd=None, git="git"):
    code, out, err = run_git([git, "rev-list", "--count", f"{base}..{tip}"], cwd=cwd)
    if code != 0:
        raise RuntimeError(err)
    return int(out)


def commits_behind(base, tip, cwd=None, git="git"):
    code, out, err = run_git([git, "rev-list", "--count", f"{tip}..{base}"], cwd=cwd)
    if code != 0:
        return 0
    return int(out)


def get_tracked_branches(remote, prefix, cwd=None, git="git"):
    code, out, err = run_git(
        [git, "for-each-ref", "--format=%(refname:short)",
         f"refs/remotes/{remote}/{prefix}"],
        cwd=cwd
    )
    if code != 0:
        raise RuntimeError(err)
    return out.splitlines() if out else []


def get_changed_files(base, tip, cwd=None, git="git"):
    code, out, err = run_git([git, "diff", "--name-only", f"{base}...{tip}"], cwd=cwd)
    if code != 0:
        return set()
    return set(out.splitlines()) if out else set()


def are_files_disjoint(branches, main_ref, remote, cwd=None, git="git"):
    all_files = []
    for branch in branches:
        files = get_changed_files(main_ref, f"{remote}/{branch}", cwd=cwd, git=git)
        all_files.append(files)

    for i in range(len(all_files)):
        for j in range(i + 1, len(all_files)):
            if all_files[i] & all_files[j]:
                return False
    return True


def local_main_ahead(remote, main, cwd=None, git="git"):
    try:
        return commits_ahead(f"{remote}/{main}", main, cwd=cwd, git=git)
    except:
        return 0


def delete_remote_branch(branch_name, remote, cwd=None, git="git"):
    code, out, err = run_git([git, "push", remote, "--delete", branch_name], cwd=cwd)
    return code == 0, err


def is_git_repo(path, git="git"):
    code, _, _ = run_git([git, "rev-parse", "--git-dir"], cwd=path)
    return code == 0


def check_git_health(repo_path, remote, main_branch, git="git"):
    code, _, err = run_git([git, "rev-parse", "--git-dir"], cwd=repo_path)
    if code != 0:
        return False, f"Pas un dÃ©pÃ´t Git: {err}"

    code, out, err = run_git([git, "remote"], cwd=repo_path)
    if code != 0:
        return False, f"Erreur git remote: {err}"
    if remote not in out.splitlines():
        return False, f"Remote '{remote}' non trouvÃ©"

    code, _, err = run_git([git, "fetch", remote, "--dry-run"], cwd=repo_path)
    if code != 0:
        return False, f"Fetch Ã©chouÃ©: {err}"

    return True, ""


# ============================================================
# SOUND & NOTIFICATIONS
# ============================================================

SOUNDS = {
    "commit": "/usr/share/sounds/freedesktop/stereo/message-new-instant.oga",
    "success": "/usr/share/sounds/freedesktop/stereo/complete.oga",
    "error": "/usr/share/sounds/freedesktop/stereo/dialog-error.oga",
    "bell": "/usr/share/sounds/freedesktop/stereo/bell.oga"
}


def play_sound(sound_type="bell"):
    sound_file = SOUNDS.get(sound_type, SOUNDS["bell"])
    try:
        subprocess.run(
            ["paplay", sound_file],
            stderr=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL
        )
    except FileNotFoundError:
        print("\a", end="", flush=True)


def send_notification(title, message, urgency="normal"):
    try:
        subprocess.run(
            ["notify-send", "-u", urgency, "-a", "GitHerd", title, message],
            stderr=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL
        )
    except FileNotFoundError:
        pass


# ============================================================
# COLORS
# ============================================================

COLOR_GREEN = "#90EE90"
COLOR_GREEN_LIGHT = "#B0FFB0"
COLOR_RED = "#FFB6C1"
COLOR_RED_LIGHT = "#FFD0D8"
COLOR_DEFAULT = "#E0E0E0"
COLOR_WHITE = "#FFFFFF"


# ============================================================
# REPO TAB
# ============================================================

class RepoTab(QWidget):
    """Un onglet gÃ©rant un seul dÃ©pÃ´t Git."""

    update_requested = Signal()

    def __init__(self, repo_path, app):
        super().__init__()

        self.repo_path = Path(repo_path)
        self.app = app
        self.git = app.global_settings.get("git_binary", "git")
        self.font_zoom = app.global_settings.get("font_zoom", 1.4)

        # Charger config repo
        self.repo_config = load_repo_config(repo_path)
        self.remote = self.repo_config["remote"]
        self.main = self.repo_config["main_branch"]
        self.prefix = self.repo_config["branch_prefix"]
        self.interval = self.repo_config["interval_seconds"]

        self.lock = threading.Lock()
        self.polling = False
        self.last_commit_count = {}
        self.pending_branches = []
        self.git_healthy = True
        self.git_error = ""
        self.next_poll_time = 0
        self.base_tab_name = self.repo_path.name
        self.has_update = False

        self._setup_ui()

        # DÃ©marrage
        QTimer.singleShot(100, self.initial_scan)

    def _setup_ui(self):
        f_ui = int(11 * self.font_zoom)
        f_title = int(12 * self.font_zoom)
        f_log = int(10 * self.font_zoom)

        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)

        # TOP BAR (status)
        self.state_label = QLabel("â³ DÃ©marrageâ€¦")
        self.state_label.setFont(QFont("Segoe UI", f_title, QFont.Bold))
        layout.addWidget(self.state_label)

        info_layout = QHBoxLayout()
        self.info_label = QLabel("Analyse en coursâ€¦")
        self.info_label.setFont(QFont("Segoe UI", f_ui))
        self.info_label.setWordWrap(True)
        info_layout.addWidget(self.info_label, 1)

        self.countdown_label = QLabel("")
        self.countdown_label.setFont(QFont("Segoe UI", f_ui))
        self.countdown_label.setStyleSheet("color: gray;")
        info_layout.addWidget(self.countdown_label)
        layout.addLayout(info_layout)

        # BUTTONS
        btn_layout = QHBoxLayout()

        self.btn_poll = QPushButton("â–¶ Start polling")
        self.btn_poll.setFont(QFont("Segoe UI", f_ui))
        self.btn_poll.clicked.connect(self.toggle_polling)
        btn_layout.addWidget(self.btn_poll)

        self.btn_sync = QPushButton("âš¡ Sync now")
        self.btn_sync.setFont(QFont("Segoe UI", f_ui))
        self.btn_sync.clicked.connect(self.manual_sync)
        btn_layout.addWidget(self.btn_sync)

        self.btn_merge = QPushButton("ðŸ”€ Merge (fichiers disjoints)")
        self.btn_merge.setFont(QFont("Segoe UI", f_ui))
        self.btn_merge.setStyleSheet("background-color: #ffcc00;")
        self.btn_merge.clicked.connect(self.manual_merge)
        self.btn_merge.hide()
        btn_layout.addWidget(self.btn_merge)

        btn_layout.addStretch()
        layout.addLayout(btn_layout)

        # LOG
        log_label = QLabel("Log")
        log_label.setFont(QFont("Segoe UI", f_ui, QFont.Bold))
        layout.addWidget(log_label)

        self.log = QTextEdit()
        self.log.setFont(QFont("Consolas", f_log))
        self.log.setReadOnly(True)
        layout.addWidget(self.log, 1)

        # Timer pour countdown
        self.countdown_timer = QTimer()
        self.countdown_timer.timeout.connect(self.update_countdown)

    def log_msg(self, txt):
        ts = datetime.now().strftime("%H:%M:%S")
        self.log.append(f"[{ts}] {txt}")

    def set_state(self, state):
        self.state_label.setText(state)

    def set_info(self, info):
        self.info_label.setText(info)

    def show_merge_button(self):
        self.btn_merge.show()

    def hide_merge_button(self):
        self.btn_merge.hide()

    def disable_tab(self, error_msg):
        self.set_state("ðŸ”´ ERREUR â€” Git non fonctionnel")
        self.set_info(error_msg)
        self.btn_poll.setEnabled(False)
        self.btn_sync.setEnabled(False)
        self.polling = False
        self.btn_poll.setText("â–¶ Start polling")
        QTimer.singleShot(0, lambda: self.app.update_tab_state(self))

    def enable_tab(self):
        self.btn_poll.setEnabled(True)
        self.btn_sync.setEnabled(True)

    def check_and_update_health(self):
        ok, err = check_git_health(self.repo_path, self.remote, self.main, self.git)
        self.git_healthy = ok
        self.git_error = err
        if not ok:
            self.disable_tab(err)
        else:
            self.enable_tab()
        return ok

    def stop_polling(self):
        self.polling = False
        self.btn_poll.setText("â–¶ Start polling")
        self.countdown_timer.stop()
        self.countdown_label.setText("")
        QTimer.singleShot(0, lambda: self.app.update_tab_state(self))

    def toggle_polling(self):
        if not self.git_healthy:
            return
        self.polling = not self.polling
        self.btn_poll.setText("â¸ Stop polling" if self.polling else "â–¶ Start polling")
        if self.polling:
            self.next_poll_time = time.time() + self.interval
            self.countdown_timer.start(1000)
            threading.Thread(target=self.polling_loop, daemon=True).start()
        else:
            self.countdown_timer.stop()
            self.countdown_label.setText("")
        self.app.update_tab_state(self)
        self.app.update_title()

    def update_countdown(self):
        if not self.polling:
            self.countdown_label.setText("")
            return
        remaining = int(self.next_poll_time - time.time())
        if remaining > 0:
            self.countdown_label.setText(f"(prochain sync: {remaining}s)")
        else:
            self.countdown_label.setText("(sync...)")

    def manual_sync(self):
        if not self.git_healthy:
            return
        threading.Thread(target=self.sync, daemon=True).start()

    def manual_merge(self):
        threading.Thread(target=self._do_merge, daemon=True).start()

    def polling_loop(self):
        next_tick = time.time()
        while self.polling:
            self.sync()
            try:
                cfg = load_repo_config(self.repo_path)
                interval = cfg.get("interval_seconds", self.interval)
            except:
                interval = self.interval
            next_tick += interval
            self.next_poll_time = next_tick
            sleep_time = max(0, next_tick - time.time())
            time.sleep(sleep_time)

    def sync(self):
        if not self.lock.acquire(blocking=False):
            return
        try:
            self._do_sync()
        finally:
            self.lock.release()

    def _do_sync(self):
        self.set_state("ðŸ”„ Syncâ€¦")
        self.hide_merge_button()
        self.pending_branches = []

        self.log_msg(f"git fetch {self.remote}")
        code, _, err = run_git([self.git, "fetch", self.remote], cwd=self.repo_path)
        if code != 0:
            self.log_msg(f"ERREUR fetch: {err}")
            self.set_state("ðŸ”´ ERREUR")
            self.stop_polling()
            return

        local_ahead = local_main_ahead(self.remote, self.main,
                                       cwd=self.repo_path, git=self.git)
        if local_ahead > 0:
            self.log_msg(f"main local en avance de {local_ahead} commits â†’ push")
            if self.push_main_and_branches():
                self.set_state("ðŸŸ¢ Sync OK")
                self.set_info(f"Push de {local_ahead} commits locaux")
                self.log_msg("âœ… Push terminÃ© avec succÃ¨s")
            return

        branches = get_tracked_branches(self.remote, self.prefix,
                                        cwd=self.repo_path, git=self.git)
        self.log_msg(f"Branches {self.prefix}*: {len(branches)}")

        ahead_branches = []
        diverged_branches = []
        new_commits_detected = False

        for b in branches:
            ahead = commits_ahead(f"{self.remote}/{self.main}", b,
                                 cwd=self.repo_path, git=self.git)
            behind = commits_behind(f"{self.remote}/{self.main}", b,
                                   cwd=self.repo_path, git=self.git)

            if ahead > 0:
                short_name = b.replace(f"{self.remote}/", "")

                if behind > 0:
                    diverged_branches.append((short_name, ahead, behind))
                    self.log_msg(f"  {short_name}: +{ahead}/-{behind} (DIVERGÃ‰E)")
                else:
                    ahead_branches.append((short_name, ahead))
                    self.log_msg(f"  {short_name}: +{ahead} commits")

                prev = self.last_commit_count.get(short_name, 0)
                if ahead > prev:
                    new_commits_detected = True
                self.last_commit_count[short_name] = ahead

        if new_commits_detected:
            self.log_msg("ðŸ”” Nouveau commit dÃ©tectÃ©!")
            threading.Thread(target=lambda: play_sound("commit"), daemon=True).start()
            if self.app.global_settings.get("desktop_notifications", True):
                send_notification(
                    f"GitHerd â€” {self.repo_path.name}",
                    "Nouveau commit dÃ©tectÃ©!",
                    "normal"
                )
            QTimer.singleShot(0, lambda: self.app.mark_tab_updated(self))

        total_problematic = len(ahead_branches) + len(diverged_branches)

        if total_problematic == 0:
            behind_branches = []
            for b in branches:
                behind = commits_behind(f"{self.remote}/{self.main}", b,
                                       cwd=self.repo_path, git=self.git)
                if behind > 0:
                    short_name = b.replace(f"{self.remote}/", "")
                    behind_branches.append((short_name, behind))
                    self.log_msg(f"  {short_name}: -{behind} commits (en retard)")

            if behind_branches:
                self.log_msg(f"Synchronisation de {len(behind_branches)} branches en retardâ€¦")
                for branch_name, _ in behind_branches:
                    refspec = f"{self.main}:{branch_name}"
                    self.log_msg(f"git push {self.remote} {refspec}")
                    code, out, err = run_git(
                        [self.git, "push", self.remote, refspec],
                        cwd=self.repo_path
                    )
                    if code != 0:
                        self.log_msg(f"ERREUR push {branch_name}: {err}")
                        self.set_state("ðŸ”´ ERREUR")
                        self.stop_polling()
                        return
                    self.log_msg(out if out else "  (ok)")

                self.set_state("ðŸŸ¢ Sync OK")
                self.set_info(f"{len(behind_branches)} branches synchronisÃ©es")
                self.log_msg("âœ… Branches en retard synchronisÃ©es")
                return

            self.set_state("ðŸŸ¢ Idle")
            self.set_info("Toutes les branches sont synchronisÃ©es")
            self.log_msg("âœ“ Rien Ã  faire")
            self.last_commit_count.clear()
            return

        if len(diverged_branches) > 0 or len(ahead_branches) > 1:
            all_names = [b[0] for b in diverged_branches] + [b[0] for b in ahead_branches]
            self.pending_branches = all_names

            self.log_msg("VÃ©rification des fichiers modifiÃ©sâ€¦")
            disjoint = are_files_disjoint(all_names, f"{self.remote}/{self.main}",
                                         self.remote, cwd=self.repo_path, git=self.git)

            if len(diverged_branches) > 0:
                diverged_names = [f"{b[0]} (+{b[1]}/-{b[2]})" for b in diverged_branches]
                msg = f"Branches divergÃ©es: {', '.join(diverged_names)}"
            else:
                msg = f"Plusieurs branches: {', '.join(all_names)}"

            if disjoint:
                self.set_state("ðŸŸ¡ STOP â€” Merge possible")
                self.set_info(f"Fichiers disjoints. {msg}")
                self.log_msg("âœ“ Fichiers disjoints â€” merge manuel possible")
                QTimer.singleShot(0, self.show_merge_button)
            else:
                self.set_state("ðŸ”´ STOP â€” Action humaine requise")
                self.set_info(f"Fichiers en conflit potentiel. {msg}")
                self.log_msg("â›” STOP: fichiers en commun dÃ©tectÃ©s")
            self.stop_polling()
            QTimer.singleShot(0, lambda: self.app.update_tab_state(self))
            return

        leader, _ = ahead_branches[0]
        self.log_msg(f"git pull --ff-only {self.remote} {leader}")
        code, out, err = run_git(
            [self.git, "pull", "--ff-only", self.remote, leader],
            cwd=self.repo_path
        )
        if code != 0:
            self.log_msg(f"ERREUR pull: {err}")
            self.set_state("ðŸ”´ ERREUR")
            self.set_info(f"Pull failed: {err[:100]}")
            self.stop_polling()
            return
        self.log_msg(out if out else "  (ok)")

        if not self.push_main_and_branches():
            return

        self.last_commit_count[leader] = 0
        self.set_state("ðŸŸ¢ Sync OK")
        branches = get_tracked_branches(self.remote, self.prefix,
                                        cwd=self.repo_path, git=self.git)
        other_count = len(branches) - 1
        self.set_info(f"Pull de {leader}, push vers {other_count} autres branches")
        self.log_msg("âœ… Sync terminÃ© avec succÃ¨s")

    def push_main_and_branches(self):
        self.log_msg(f"git push {self.remote} {self.main}")
        code, out, err = run_git([self.git, "push", self.remote, self.main],
                                cwd=self.repo_path)
        if code != 0:
            self.log_msg(f"ERREUR push main: {err}")
            self.set_state("ðŸ”´ ERREUR")
            self.stop_polling()
            return False
        self.log_msg(out if out else "  (ok)")

        branches = get_tracked_branches(self.remote, self.prefix,
                                        cwd=self.repo_path, git=self.git)
        for b in branches:
            target = b.replace(f"{self.remote}/", "")
            refspec = f"{self.main}:{target}"
            self.log_msg(f"git push {self.remote} {refspec}")
            code, out, err = run_git([self.git, "push", self.remote, refspec],
                                    cwd=self.repo_path)
            if code != 0:
                self.log_msg(f"ERREUR push {target}: {err}")
                self.set_state("ðŸ”´ STOP â€” Push failed")
                self.set_info(f"Push vers {target} a Ã©chouÃ©")
                self.stop_polling()
                return False
            self.log_msg(out if out else "  (ok)")

        return True

    def _do_merge(self):
        if not self.lock.acquire(blocking=False):
            return
        try:
            self._do_merge_impl()
        finally:
            self.lock.release()

    def _do_merge_impl(self):
        if not self.pending_branches:
            self.log_msg("Aucune branche en attente de merge")
            return

        self.set_state("ðŸ”€ Merge en coursâ€¦")
        self.hide_merge_button()

        branches = self.pending_branches[:]
        self.log_msg(f"Merge de {len(branches)} branches: {', '.join(branches)}")

        for branch in branches:
            self.log_msg(f"git merge {self.remote}/{branch}")
            code, out, err = run_git(
                [self.git, "merge", f"{self.remote}/{branch}", "-m", f"Merge {branch}"],
                cwd=self.repo_path
            )
            if code != 0:
                self.log_msg(f"ERREUR merge {branch}: {err}")
                self.set_state("ðŸ”´ ERREUR â€” Merge Ã©chouÃ©")
                self.set_info(f"Merge de {branch} a Ã©chouÃ©")
                run_git([self.git, "merge", "--abort"], cwd=self.repo_path)
                self.stop_polling()
                return
            self.log_msg(out if out else "  (ok)")

        if not self.push_main_and_branches():
            return

        self.pending_branches = []
        self.last_commit_count.clear()
        self.set_state("ðŸŸ¢ Merge OK")
        self.set_info(f"Merge de {len(branches)} branches terminÃ©")
        self.log_msg("âœ… Merge terminÃ© avec succÃ¨s")
        QTimer.singleShot(0, lambda: self.app.update_tab_state(self))

    def initial_scan(self):
        if not self.check_and_update_health():
            self.log_msg(f"âŒ {self.git_error}")
            return

        try:
            run_git([self.git, "fetch", self.remote], cwd=self.repo_path)

            local_ahead = local_main_ahead(self.remote, self.main,
                                          cwd=self.repo_path, git=self.git)
            if local_ahead > 0:
                self.set_state("ðŸŸ¡ main local en avance")
                self.set_info(f"+{local_ahead} commits Ã  pusher â€” cliquer Sync now")
                return

            branches = get_tracked_branches(self.remote, self.prefix,
                                           cwd=self.repo_path, git=self.git)

            ahead_list = []
            diverged_list = []

            for b in branches:
                ahead = commits_ahead(f"{self.remote}/{self.main}", b,
                                     cwd=self.repo_path, git=self.git)
                behind = commits_behind(f"{self.remote}/{self.main}", b,
                                       cwd=self.repo_path, git=self.git)

                if ahead > 0:
                    short_name = b.replace(f"{self.remote}/", "")
                    self.last_commit_count[short_name] = ahead

                    if behind > 0:
                        diverged_list.append((short_name, ahead, behind))
                    else:
                        ahead_list.append(short_name)

            total = len(ahead_list) + len(diverged_list)

            if total == 0:
                behind_list = []
                for b in branches:
                    behind = commits_behind(f"{self.remote}/{self.main}", b,
                                           cwd=self.repo_path, git=self.git)
                    if behind > 0:
                        short_name = b.replace(f"{self.remote}/", "")
                        behind_list.append((short_name, behind))

                if behind_list:
                    names = [f"{b[0]} (-{b[1]})" for b in behind_list]
                    self.set_state("ðŸŸ¡ Branches en retard")
                    self.set_info(f"Ã€ synchroniser: {', '.join(names)}")
                else:
                    self.set_state("ðŸŸ¢ Idle")
                    self.set_info("Toutes les branches sont synchronisÃ©es")
            elif len(diverged_list) == 0 and len(ahead_list) == 1:
                self.set_state("ðŸŸ¡ 1 branche en avance")
                self.set_info(f"PrÃªt Ã  sync: {ahead_list[0]}")
            else:
                all_names = [b[0] for b in diverged_list] + ahead_list
                self.pending_branches = all_names

                disjoint = are_files_disjoint(all_names, f"{self.remote}/{self.main}",
                                             self.remote, cwd=self.repo_path, git=self.git)

                if len(diverged_list) > 0:
                    diverged_info = [f"{b[0]} (+{b[1]}/-{b[2]})" for b in diverged_list]
                    msg = f"DivergÃ©es: {', '.join(diverged_info)}"
                else:
                    msg = f"Plusieurs branches: {', '.join(all_names)}"

                if disjoint:
                    self.set_state("ðŸŸ¡ STOP â€” Merge possible")
                    self.set_info(f"Fichiers disjoints. {msg}")
                    QTimer.singleShot(100, self.show_merge_button)
                else:
                    self.set_state("ðŸ”´ STOP â€” Action humaine requise")
                    self.set_info(msg)

                QTimer.singleShot(0, lambda: self.app.update_tab_state(self))

        except Exception as e:
            self.set_state("ðŸ”´ ERREUR")
            self.set_info(str(e))
            QTimer.singleShot(0, lambda: self.app.update_tab_state(self))

    def export_log(self):
        filename, _ = QFileDialog.getSaveFileName(
            self, "Exporter le log",
            f"githerd-{self.repo_path.name}-{datetime.now().strftime('%Y%m%d-%H%M%S')}.txt",
            "Fichiers texte (*.txt)"
        )
        if filename:
            try:
                with open(filename, "w") as f:
                    f.write(f"GitHerd Log - {self.repo_path}\n")
                    f.write(f"Exported: {datetime.now()}\n")
                    f.write("=" * 50 + "\n\n")
                    f.write(self.log.toPlainText())
                self.log_msg(f"âœ… Log exportÃ© vers {filename}")
            except Exception as e:
                QMessageBox.critical(self, "Erreur", f"Impossible d'exporter: {e}")

    def open_folder(self):
        try:
            subprocess.run(["xdg-open", str(self.repo_path)],
                          stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL)
        except:
            pass


# ============================================================
# MAIN APP
# ============================================================

class App(QMainWindow):
    def __init__(self):
        super().__init__()

        self.tabs = {}  # repo_path -> RepoTab
        self.global_settings = load_global_settings()
        self.font_zoom = self.global_settings.get("font_zoom", 1.4)

        self.setWindowTitle("GitHerd")
        self.resize(1000, 700)

        f_ui = int(11 * self.font_zoom)

        # Central widget
        central = QWidget()
        self.setCentralWidget(central)
        layout = QVBoxLayout(central)
        layout.setContentsMargins(5, 5, 5, 5)

        # Tab widget
        self.notebook = QTabWidget()
        self.notebook.setTabsClosable(True)
        self.notebook.tabCloseRequested.connect(self.close_tab_by_index)
        self.notebook.currentChanged.connect(self.on_tab_changed)
        self.notebook.setFont(QFont("Segoe UI", int(10 * self.font_zoom)))
        layout.addWidget(self.notebook)

        # Menu bar
        self._setup_menus(f_ui)

        # Shortcuts
        self._setup_shortcuts()

        # Load saved repos
        self.load_saved_repos()

        if not self.tabs:
            QTimer.singleShot(100, self.add_repo_dialog)

        # Always on top
        self.setWindowFlags(self.windowFlags() | Qt.WindowStaysOnTopHint)

    def _setup_menus(self, f_ui):
        menubar = self.menuBar()
        menubar.setFont(QFont("Segoe UI", f_ui))

        # Fichier
        file_menu = menubar.addMenu("Fichier")
        file_menu.addAction("Ajouter un repo...", self.add_repo_dialog, "Ctrl+O")
        file_menu.addAction("Stopper tous les polling", self.stop_all_polling, "Ctrl+S")
        file_menu.addSeparator()
        file_menu.addAction("RedÃ©marrer", self.restart_app, "Ctrl+R")
        file_menu.addAction("Quitter", self.close, "Ctrl+Q")

        # Repository
        self.repo_menu = menubar.addMenu("Repository")
        self.repo_menu.aboutToShow.connect(self.update_repo_menu)

        # Options
        options_menu = menubar.addMenu("Options")
        options_menu.addAction("ParamÃ¨tres globaux...", self.show_global_settings)

        # Aide
        help_menu = menubar.addMenu("Aide")
        help_menu.addAction("Ã€ propos de GitHerd", self.show_help)

    def _setup_shortcuts(self):
        QShortcut(QKeySequence("Ctrl+Tab"), self, self.next_tab)
        QShortcut(QKeySequence("Ctrl+Shift+Tab"), self, self.prev_tab)
        QShortcut(QKeySequence("Ctrl+M"), self, self.toggle_compact_mode)

    def load_saved_repos(self):
        repos = load_saved_repos()
        git = self.global_settings.get("git_binary", "git")
        for repo_path in repos:
            if Path(repo_path).exists() and is_git_repo(repo_path, git):
                self.add_repo(repo_path)

    def save_current_repos(self):
        repos = list(self.tabs.keys())
        save_repos(repos)

    def add_repo_dialog(self):
        path = QFileDialog.getExistingDirectory(self, "SÃ©lectionner un dÃ©pÃ´t Git")
        if path:
            git = self.global_settings.get("git_binary", "git")
            if not is_git_repo(path, git):
                QMessageBox.critical(self, "Erreur", f"'{path}' n'est pas un dÃ©pÃ´t Git valide.")
                return
            if path in self.tabs:
                QMessageBox.information(self, "Info", "Ce dÃ©pÃ´t est dÃ©jÃ  ouvert.")
                idx = list(self.tabs.keys()).index(path)
                self.notebook.setCurrentIndex(idx)
                return

            detected = detect_repo_settings(path, git)
            config_file = Path(path) / "githerd.toml"
            if not config_file.exists():
                save_repo_config(path, detected)

            self.add_repo(path)
            self.save_current_repos()

    def add_repo(self, repo_path):
        tab = RepoTab(repo_path, self)
        repo_name = Path(repo_path).name

        idx = self.notebook.addTab(tab, repo_name)
        self.tabs[repo_path] = tab
        self.notebook.setCurrentIndex(idx)

        self.update_title()

        if self.global_settings.get("auto_start_polling", False):
            QTimer.singleShot(500, tab.toggle_polling)

    def get_tab_bg_state(self, tab):
        if not tab.git_healthy:
            return "red"
        if tab.pending_branches and not tab.polling:
            return "red"
        if tab.polling:
            return "green"
        return "default"

    def update_tab_state(self, tab):
        """Met Ã  jour le style de l'onglet (couleur de fond)."""
        try:
            idx = list(self.tabs.values()).index(tab)
        except ValueError:
            return

        bg_state = self.get_tab_bg_state(tab)
        name = tab.base_tab_name
        if tab.has_update:
            name = f"â— {name}"

        self.notebook.setTabText(idx, name)

        # Set tab color
        tab_bar = self.notebook.tabBar()
        if bg_state == "green":
            tab_bar.setTabTextColor(idx, QColor("#006400"))  # Dark green text
            # Use stylesheet for background
        elif bg_state == "red":
            tab_bar.setTabTextColor(idx, QColor("#8B0000"))  # Dark red text
        else:
            tab_bar.setTabTextColor(idx, QColor("#000000"))

        self._update_tab_stylesheet()

    def _update_tab_stylesheet(self):
        """Update stylesheet for all tabs based on their state."""
        style_parts = []
        for i, (path, tab) in enumerate(self.tabs.items()):
            bg_state = self.get_tab_bg_state(tab)
            if bg_state == "green":
                bg_color = COLOR_GREEN
            elif bg_state == "red":
                bg_color = COLOR_RED
            else:
                bg_color = COLOR_DEFAULT

            style_parts.append(f"""
                QTabBar::tab:nth({i}) {{
                    background-color: {bg_color};
                }}
            """)

        # Simple approach: color all tabs based on state with generic selector
        # Qt doesn't support :nth() well, so we'll use a different approach
        pass  # Tab coloring will be done differently

    def mark_tab_updated(self, tab):
        if not tab.has_update:
            current_tab = self.notebook.currentWidget()
            if current_tab != tab:
                tab.has_update = True
                self.update_tab_state(tab)

    def clear_tab_marker(self, tab):
        if tab.has_update:
            tab.has_update = False
            self.update_tab_state(tab)

    def on_tab_changed(self, index):
        if index >= 0:
            tab = self.notebook.widget(index)
            if tab:
                self.clear_tab_marker(tab)

    def close_tab_by_index(self, index):
        tab = self.notebook.widget(index)
        if tab:
            self.close_tab(tab)

    def close_tab(self, tab):
        repo_path = None
        for path, t in self.tabs.items():
            if t == tab:
                repo_path = path
                break

        if repo_path:
            tab.polling = False
            tab.countdown_timer.stop()
            del self.tabs[repo_path]
            idx = self.notebook.indexOf(tab)
            self.notebook.removeTab(idx)
            self.save_current_repos()
            self.update_title()

    def update_repo_menu(self):
        self.repo_menu.clear()
        tab = self.notebook.currentWidget()
        if not tab or not isinstance(tab, RepoTab):
            self.repo_menu.addAction("(aucun repo)").setEnabled(False)
            return

        self.repo_menu.addAction("Configuration...", lambda: self.show_repo_config(tab))
        self.repo_menu.addSeparator()
        self.repo_menu.addAction("Sync now", tab.manual_sync)

        polling_label = "ArrÃªter polling" if tab.polling else "DÃ©marrer polling"
        self.repo_menu.addAction(polling_label, tab.toggle_polling)
        self.repo_menu.addSeparator()

        try:
            branches = get_tracked_branches(tab.remote, tab.prefix,
                                           cwd=tab.repo_path, git=tab.git)
        except:
            branches = []

        if branches:
            for b in branches:
                short_name = b.replace(f"{tab.remote}/", "")
                self.repo_menu.addAction(f"Supprimer {short_name}",
                                        lambda bn=short_name: self.delete_branch(tab, bn))
            self.repo_menu.addSeparator()

        self.repo_menu.addAction("Exporter log...", tab.export_log)
        self.repo_menu.addAction("Ouvrir dossier", tab.open_folder)
        self.repo_menu.addAction("Test son", lambda: threading.Thread(target=play_sound, daemon=True).start())
        self.repo_menu.addSeparator()
        self.repo_menu.addAction("Fermer cet onglet", lambda: self.close_tab(tab))

    def delete_branch(self, tab, branch_name):
        reply = QMessageBox.question(
            self, "Confirmer suppression",
            f"Supprimer la branche remote '{branch_name}' ?\n\nCette action est irrÃ©versible.",
            QMessageBox.Yes | QMessageBox.No
        )
        if reply == QMessageBox.Yes:
            tab.log_msg(f"Suppression de {branch_name}â€¦")
            success, err = delete_remote_branch(branch_name, tab.remote,
                                               cwd=tab.repo_path, git=tab.git)
            if success:
                tab.log_msg(f"âœ… Branche {branch_name} supprimÃ©e")
                tab.manual_sync()
            else:
                tab.log_msg(f"âŒ Erreur: {err}")

    def show_repo_config(self, tab):
        dialog = QDialog(self)
        dialog.setWindowTitle(f"Configuration â€” {tab.repo_path.name}")
        dialog.setMinimumWidth(400)

        layout = QFormLayout(dialog)

        remote_edit = QLineEdit(tab.remote)
        layout.addRow("Remote:", remote_edit)

        main_edit = QLineEdit(tab.main)
        layout.addRow("Main branch:", main_edit)

        prefix_edit = QLineEdit(tab.prefix)
        layout.addRow("Branch prefix:", prefix_edit)

        interval_spin = QSpinBox()
        interval_spin.setRange(5, 3600)
        interval_spin.setValue(tab.interval)
        layout.addRow("Interval (sec):", interval_spin)

        btn_layout = QHBoxLayout()
        save_btn = QPushButton("Sauvegarder")
        cancel_btn = QPushButton("Annuler")
        btn_layout.addWidget(save_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addRow(btn_layout)

        def save():
            tab.remote = remote_edit.text().strip()
            tab.main = main_edit.text().strip()
            tab.prefix = prefix_edit.text().strip()
            tab.interval = interval_spin.value()

            tab.repo_config = {
                "remote": tab.remote,
                "main_branch": tab.main,
                "branch_prefix": tab.prefix,
                "interval_seconds": tab.interval
            }

            try:
                save_repo_config(tab.repo_path, tab.repo_config)
                tab.log_msg("âœ… Configuration sauvegardÃ©e")
                tab.check_and_update_health()
            except Exception as e:
                QMessageBox.critical(dialog, "Erreur", f"Impossible de sauvegarder: {e}")
                return

            dialog.accept()

        save_btn.clicked.connect(save)
        cancel_btn.clicked.connect(dialog.reject)
        dialog.exec()

    def show_global_settings(self):
        dialog = QDialog(self)
        dialog.setWindowTitle("ParamÃ¨tres globaux")
        dialog.setMinimumWidth(450)

        layout = QFormLayout(dialog)

        git_edit = QLineEdit(self.global_settings.get("git_binary", "git"))
        layout.addRow("Git binary:", git_edit)

        zoom_spin = QDoubleSpinBox()
        zoom_spin.setRange(0.5, 3.0)
        zoom_spin.setSingleStep(0.1)
        zoom_spin.setValue(self.global_settings.get("font_zoom", 1.4))
        layout.addRow("Font zoom:", zoom_spin)

        auto_poll_check = QCheckBox()
        auto_poll_check.setChecked(self.global_settings.get("auto_start_polling", False))
        layout.addRow("DÃ©marrer polling auto:", auto_poll_check)

        notif_check = QCheckBox()
        notif_check.setChecked(self.global_settings.get("desktop_notifications", True))
        layout.addRow("Notifications desktop:", notif_check)

        btn_layout = QHBoxLayout()
        save_btn = QPushButton("Sauvegarder")
        cancel_btn = QPushButton("Annuler")
        btn_layout.addWidget(save_btn)
        btn_layout.addWidget(cancel_btn)
        layout.addRow(btn_layout)

        def save():
            self.global_settings["git_binary"] = git_edit.text().strip()
            self.global_settings["font_zoom"] = zoom_spin.value()
            self.global_settings["auto_start_polling"] = auto_poll_check.isChecked()
            self.global_settings["desktop_notifications"] = notif_check.isChecked()

            try:
                save_global_settings(self.global_settings)
                QMessageBox.information(
                    dialog, "Info",
                    "ParamÃ¨tres sauvegardÃ©s.\nRedÃ©marrez GitHerd pour appliquer le changement de zoom."
                )
            except Exception as e:
                QMessageBox.critical(dialog, "Erreur", f"Impossible de sauvegarder: {e}")
                return

            dialog.accept()

        save_btn.clicked.connect(save)
        cancel_btn.clicked.connect(dialog.reject)
        dialog.exec()

    def show_help(self):
        QMessageBox.about(
            self, "Ã€ propos de GitHerd",
            "GitHerd â€” Real-time Git branch synchronizer\n\n"
            "Keeps multiple Git branches aligned in real-time.\n"
            "Ideal for parallel AI coding sessions.\n\n"
            "https://github.com/Jacques66/GitHerd"
        )

    def update_title(self):
        total = len(self.tabs)
        polling = sum(1 for t in self.tabs.values() if t.polling)
        if total == 0:
            self.setWindowTitle("GitHerd")
        elif polling > 0:
            self.setWindowTitle(f"GitHerd â€” {total} repos, {polling} polling")
        else:
            self.setWindowTitle(f"GitHerd â€” {total} repos")

    def next_tab(self):
        count = self.notebook.count()
        if count < 2:
            return
        current = self.notebook.currentIndex()
        self.notebook.setCurrentIndex((current + 1) % count)

    def prev_tab(self):
        count = self.notebook.count()
        if count < 2:
            return
        current = self.notebook.currentIndex()
        self.notebook.setCurrentIndex((current - 1) % count)

    def toggle_compact_mode(self):
        # TODO: implement compact mode
        pass

    def stop_all_polling(self):
        stopped = 0
        for tab in self.tabs.values():
            if tab.polling:
                tab.polling = False
                tab.countdown_timer.stop()
                tab.countdown_label.setText("")
                tab.btn_poll.setText("â–¶ Start polling")
                self.update_tab_state(tab)
                stopped += 1

        self.update_title()

        if stopped > 0:
            QMessageBox.information(
                self, "Polling arrÃªtÃ©",
                f"{stopped} polling(s) arrÃªtÃ©(s).\nLes syncs en cours se termineront."
            )

    def restart_app(self):
        any_sync_locked = any(tab.lock.locked() for tab in self.tabs.values())
        if any_sync_locked:
            QMessageBox.warning(
                self, "Sync en cours",
                "Impossible de redÃ©marrer : une synchronisation est en cours.\n"
                "Attendez la fin de la sync."
            )
            return

        polling_count = sum(1 for tab in self.tabs.values() if tab.polling)
        if polling_count > 0:
            reply = QMessageBox.question(
                self, "Polling en cours",
                f"{polling_count} polling(s) actif(s).\n\n"
                "ArrÃªter les polling et redÃ©marrer ?",
                QMessageBox.Yes | QMessageBox.No
            )
            if reply != QMessageBox.Yes:
                return

            for tab in self.tabs.values():
                if tab.polling:
                    tab.polling = False
                    tab.countdown_timer.stop()

        self.save_current_repos()
        python = sys.executable
        script = os.path.abspath(__file__)
        self.close()
        os.execl(python, python, script)

    def closeEvent(self, event):
        for tab in self.tabs.values():
            tab.polling = False
            tab.countdown_timer.stop()
        self.save_current_repos()
        event.accept()


# ============================================================

if __name__ == "__main__":
    app = QApplication(sys.argv)
    app.setStyle("Fusion")  # Modern look
    window = App()
    window.show()
    sys.exit(app.exec())
