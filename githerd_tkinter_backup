#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GitHerd â€” Real-time Git branch synchronizer

Keeps multiple Git branches aligned in real-time.
Ideal for parallel AI coding sessions (Claude Code, Cursor, etc.)
or any workflow with multiple active branches.

Copyright (c) 2026 InZeMobile
Licensed under the MIT License. See LICENSE file for details.

https://github.com/Jacques66/GitHerd
"""

import subprocess
import threading
import time
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from tkinter.scrolledtext import ScrolledText
from pathlib import Path
from datetime import datetime
import json
import sys
import os

# ============================================================
# CONFIG & PERSISTENCE
# ============================================================

CONFIG_DIR = Path.home() / ".config" / "githerd"
REPOS_FILE = CONFIG_DIR / "repos.json"
SETTINGS_FILE = CONFIG_DIR / "settings.json"

DEFAULT_GLOBAL_SETTINGS = {
    "git_binary": "git",
    "font_zoom": 1.6,
    "auto_start_polling": False,
    "compact_mode": False,
    "desktop_notifications": True
}

DEFAULT_REPO_CONFIG = {
    "remote": "origin",
    "main_branch": "main",
    "branch_prefix": "claude/",
    "interval_seconds": 60
}

try:
    import tomllib
except ModuleNotFoundError:
    import tomli as tomllib


def load_global_settings():
    """Charge les settings globaux."""
    if SETTINGS_FILE.exists():
        try:
            with open(SETTINGS_FILE, "r") as f:
                data = json.load(f)
                # Merge avec defaults
                settings = DEFAULT_GLOBAL_SETTINGS.copy()
                settings.update(data)
                return settings
        except Exception:
            pass
    return DEFAULT_GLOBAL_SETTINGS.copy()


def save_global_settings(settings):
    """Sauvegarde les settings globaux."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    with open(SETTINGS_FILE, "w") as f:
        json.dump(settings, f, indent=2)


def load_repo_config(repo_path):
    """Charge la config depuis githerd.toml du repo, ou utilise les valeurs par dÃ©faut."""
    config_file = Path(repo_path) / "githerd.toml"
    if config_file.exists():
        try:
            cfg = tomllib.load(open(config_file, "rb"))
            # Extraire les valeurs pertinentes
            return {
                "remote": cfg.get("git", {}).get("remote", DEFAULT_REPO_CONFIG["remote"]),
                "main_branch": cfg.get("git", {}).get("main_branch", DEFAULT_REPO_CONFIG["main_branch"]),
                "branch_prefix": cfg.get("git", {}).get("branch_prefix", DEFAULT_REPO_CONFIG["branch_prefix"]),
                "interval_seconds": cfg.get("sync", {}).get("interval_seconds", DEFAULT_REPO_CONFIG["interval_seconds"])
            }
        except Exception:
            pass
    return DEFAULT_REPO_CONFIG.copy()


def save_repo_config(repo_path, config):
    """Sauvegarde la config dans githerd.toml du repo."""
    config_file = Path(repo_path) / "githerd.toml"
    toml_content = f'''[git]
remote = "{config['remote']}"
main_branch = "{config['main_branch']}"
branch_prefix = "{config['branch_prefix']}"

[sync]
interval_seconds = {config['interval_seconds']}
'''
    with open(config_file, "w") as f:
        f.write(toml_content)


def load_saved_repos():
    """Charge la liste des repos sauvegardÃ©s."""
    if REPOS_FILE.exists():
        try:
            with open(REPOS_FILE, "r") as f:
                data = json.load(f)
                return data.get("repos", [])
        except Exception:
            pass
    return []


def save_repos(repos):
    """Sauvegarde la liste des repos."""
    CONFIG_DIR.mkdir(parents=True, exist_ok=True)
    with open(REPOS_FILE, "w") as f:
        json.dump({"repos": repos}, f, indent=2)


def detect_repo_settings(repo_path, git_binary="git"):
    """DÃ©tecte automatiquement remote et main_branch du repo."""
    settings = DEFAULT_REPO_CONFIG.copy()

    # DÃ©tecter le remote
    code, out, _ = run_git([git_binary, "remote"], cwd=repo_path)
    if code == 0 and out:
        remotes = out.splitlines()
        if remotes:
            settings["remote"] = remotes[0]  # Premier remote

    # DÃ©tecter la branche principale
    remote = settings["remote"]
    code, out, _ = run_git(
        [git_binary, "symbolic-ref", f"refs/remotes/{remote}/HEAD"],
        cwd=repo_path
    )
    if code == 0 and out:
        # Format: refs/remotes/origin/main
        parts = out.split("/")
        if len(parts) >= 4:
            settings["main_branch"] = parts[-1]
    else:
        # Fallback: chercher main ou master
        code, out, _ = run_git(
            [git_binary, "branch", "-r", "--list", f"{remote}/main"],
            cwd=repo_path
        )
        if code == 0 and out.strip():
            settings["main_branch"] = "main"
        else:
            code, out, _ = run_git(
                [git_binary, "branch", "-r", "--list", f"{remote}/master"],
                cwd=repo_path
            )
            if code == 0 and out.strip():
                settings["main_branch"] = "master"

    return settings


HELP_TEXT = """GitHerd â€” Real-time Git branch synchronizer

Keeps multiple Git branches aligned in real-time.
Ideal for parallel AI coding sessions or any workflow
with multiple active branches.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

TABLEAU DES CAS GÃ‰RÃ‰S :

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Situation                               â”‚ Action              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Rien Ã  faire                            â”‚ ğŸŸ¢ Idle             â”‚
â”‚ main local en avance                    â”‚ Push auto           â”‚
â”‚ Branches en retard sur main             â”‚ Push auto to sync   â”‚
â”‚ 1 branche en avance (pas divergente)    â”‚ Fast-forward + push â”‚
â”‚ 1+ branche divergente, fichiers disjointâ”‚ ğŸŸ¡ Bouton merge     â”‚
â”‚ 1+ branche divergente, fichiers communs â”‚ ğŸ”´ STOP             â”‚
â”‚ 2+ branches en avance, fichiers disjointâ”‚ ğŸŸ¡ Bouton merge     â”‚
â”‚ 2+ branches en avance, fichiers communs â”‚ ğŸ”´ STOP             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

MULTI-REPO :

- Menu Fichier > Ajouter un repo (Ctrl+O)
- Chaque onglet gÃ¨re un dÃ©pÃ´t indÃ©pendamment
- Les repos sont sauvegardÃ©s entre les sessions
- Clic droit sur un onglet pour le fermer

INDICATEURS D'ONGLET :
- Fond vert pastel = Polling actif
- Fond gris = Polling inactif
- Fond rouge pastel = STOP (action requise ou erreur)
- â— devant le nom = Mise Ã  jour dÃ©tectÃ©e (cliquer pour effacer)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

CONFIGURATION :

Menu Options > ParamÃ¨tres globaux :
- Git binary : chemin vers l'exÃ©cutable git
- Font zoom : taille de police de l'interface

Menu Repository > Configuration :
- Remote, Main branch, Branch prefix, Interval

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

RACCOURCIS CLAVIER :

- Ctrl+O : Ajouter un repo
- Ctrl+S : Stopper tous les polling
- Ctrl+R : RedÃ©marrer (si aucune action en cours)
- Ctrl+Q : Quitter
- Ctrl+Tab : Onglet suivant
- Ctrl+Shift+Tab : Onglet prÃ©cÃ©dent
- Ctrl+M : Basculer mode compact

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

FONCTIONNALITÃ‰S :

- Countdown avant prochain poll
- Notifications desktop (notify-send)
- Sons diffÃ©renciÃ©s (commit/succÃ¨s/erreur)
- Export des logs vers fichier
- Status dans le titre de la fenÃªtre
- Mode compact (masque boutons et logs)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

BUT : Ã‰viter les merges quand plusieurs instances
travaillent sur le mÃªme repo. L'outil garde toutes
les branches alignÃ©es en temps rÃ©el.

DÃ©terministe. Pas d'heuristique. Pas de magie.

https://github.com/Jacques66/GitHerd
"""

# ============================================================
# GIT HELPERS
# ============================================================

def run_git(cmd, cwd=None):
    try:
        p = subprocess.run(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            cwd=cwd,
            timeout=30
        )
        return p.returncode, p.stdout.strip(), p.stderr.strip()
    except subprocess.TimeoutExpired:
        return 1, "", "Timeout"
    except FileNotFoundError:
        return 1, "", f"Command not found: {cmd[0]}"
    except Exception as e:
        return 1, "", str(e)


def commits_ahead(base, tip, cwd=None, git="git"):
    """Retourne le nombre de commits que tip a en avance sur base."""
    code, out, err = run_git([git, "rev-list", "--count", f"{base}..{tip}"], cwd=cwd)
    if code != 0:
        raise RuntimeError(err)
    return int(out)


def commits_behind(base, tip, cwd=None, git="git"):
    """Retourne le nombre de commits que tip a en retard sur base."""
    code, out, err = run_git([git, "rev-list", "--count", f"{tip}..{base}"], cwd=cwd)
    if code != 0:
        return 0
    return int(out)


def get_tracked_branches(remote, prefix, cwd=None, git="git"):
    """Liste toutes les branches remote avec le prÃ©fixe configurÃ©."""
    code, out, err = run_git(
        [git, "for-each-ref", "--format=%(refname:short)",
         f"refs/remotes/{remote}/{prefix}"],
        cwd=cwd
    )
    if code != 0:
        raise RuntimeError(err)
    return out.splitlines() if out else []


def get_changed_files(base, tip, cwd=None, git="git"):
    """Retourne l'ensemble des fichiers modifiÃ©s entre base et tip."""
    code, out, err = run_git([git, "diff", "--name-only", f"{base}...{tip}"], cwd=cwd)
    if code != 0:
        return set()
    return set(out.splitlines()) if out else set()


def are_files_disjoint(branches, main_ref, remote, cwd=None, git="git"):
    """VÃ©rifie si les fichiers modifiÃ©s par chaque branche sont disjoints."""
    all_files = []
    for branch in branches:
        files = get_changed_files(main_ref, f"{remote}/{branch}", cwd=cwd, git=git)
        all_files.append(files)

    for i in range(len(all_files)):
        for j in range(i + 1, len(all_files)):
            if all_files[i] & all_files[j]:
                return False
    return True


def local_main_ahead(remote, main, cwd=None, git="git"):
    """VÃ©rifie si main local est en avance sur origin/main."""
    try:
        return commits_ahead(f"{remote}/{main}", main, cwd=cwd, git=git)
    except:
        return 0


def delete_remote_branch(branch_name, remote, cwd=None, git="git"):
    """Supprime une branche remote."""
    code, out, err = run_git([git, "push", remote, "--delete", branch_name], cwd=cwd)
    return code == 0, err


def is_git_repo(path, git="git"):
    """VÃ©rifie si un chemin est un dÃ©pÃ´t Git."""
    code, _, _ = run_git([git, "rev-parse", "--git-dir"], cwd=path)
    return code == 0


def check_git_health(repo_path, remote, main_branch, git="git"):
    """VÃ©rifie que Git est fonctionnel dans ce repo. Retourne (ok, error_msg)."""
    # Test 1: est-ce un repo git ?
    code, _, err = run_git([git, "rev-parse", "--git-dir"], cwd=repo_path)
    if code != 0:
        return False, f"Pas un dÃ©pÃ´t Git: {err}"

    # Test 2: le remote existe ?
    code, out, err = run_git([git, "remote"], cwd=repo_path)
    if code != 0:
        return False, f"Erreur git remote: {err}"
    if remote not in out.splitlines():
        return False, f"Remote '{remote}' non trouvÃ©"

    # Test 3: peut-on faire un fetch ?
    code, _, err = run_git([git, "fetch", remote, "--dry-run"], cwd=repo_path)
    if code != 0:
        return False, f"Fetch Ã©chouÃ©: {err}"

    return True, ""


# ============================================================
# SOUND & NOTIFICATIONS
# ============================================================

SOUNDS = {
    "commit": "/usr/share/sounds/freedesktop/stereo/message-new-instant.oga",
    "success": "/usr/share/sounds/freedesktop/stereo/complete.oga",
    "error": "/usr/share/sounds/freedesktop/stereo/dialog-error.oga",
    "bell": "/usr/share/sounds/freedesktop/stereo/bell.oga"
}


def play_sound(sound_type="bell"):
    """Joue un son de notification."""
    sound_file = SOUNDS.get(sound_type, SOUNDS["bell"])
    try:
        subprocess.run(
            ["paplay", sound_file],
            stderr=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL
        )
    except FileNotFoundError:
        print("\a", end="", flush=True)


def send_notification(title, message, urgency="normal"):
    """Envoie une notification desktop."""
    try:
        subprocess.run(
            ["notify-send", "-u", urgency, "-a", "GitHerd", title, message],
            stderr=subprocess.DEVNULL,
            stdout=subprocess.DEVNULL
        )
    except FileNotFoundError:
        pass


def play_beep():
    """CompatibilitÃ©: joue un son de notification."""
    play_sound("bell")


# ============================================================
# REPO TAB
# ============================================================

class RepoTab(ttk.Frame):
    """Un onglet gÃ©rant un seul dÃ©pÃ´t Git."""

    def __init__(self, parent, repo_path, app):
        super().__init__(parent)

        self.repo_path = Path(repo_path)
        self.app = app
        self.git = app.global_settings.get("git_binary", "git")
        self.font_zoom = app.global_settings.get("font_zoom", 1.6)

        # Charger config repo
        self.repo_config = load_repo_config(repo_path)
        self.remote = self.repo_config["remote"]
        self.main = self.repo_config["main_branch"]
        self.prefix = self.repo_config["branch_prefix"]
        self.interval = self.repo_config["interval_seconds"]

        self.lock = threading.Lock()
        self.polling = False
        self.log_visible = True
        self.last_commit_count = {}
        self.pending_branches = []
        self.git_healthy = True
        self.git_error = ""
        self.next_poll_time = 0
        self.countdown_job = None
        self.compact_mode = app.global_settings.get("compact_mode", False)

        f_ui = int(11 * self.font_zoom)
        f_title = int(12 * self.font_zoom)
        f_log = int(11 * self.font_zoom)
        self.f_ui = f_ui

        # TOP BAR (status)
        top_bar = ttk.Frame(self)
        top_bar.pack(fill="x", padx=10, pady=6)

        self.state_var = tk.StringVar(value="â³ DÃ©marrageâ€¦")
        self.info_var = tk.StringVar(value="Analyse en coursâ€¦")
        self.countdown_var = tk.StringVar(value="")

        tk.Label(top_bar, textvariable=self.state_var,
                 font=("Segoe UI", f_title, "bold")).pack(anchor="w", padx=5)

        # Info + countdown sur la mÃªme ligne
        info_frame = ttk.Frame(top_bar)
        info_frame.pack(anchor="w", fill="x")
        tk.Label(info_frame, textvariable=self.info_var,
                 font=("Segoe UI", f_ui), wraplength=600).pack(side="left", padx=5)
        self.countdown_label = tk.Label(info_frame, textvariable=self.countdown_var,
                 font=("Segoe UI", f_ui), fg="gray")
        self.countdown_label.pack(side="left", padx=10)

        # BUTTONS
        self.buttons_frame = ttk.Frame(self)
        self.buttons_frame.pack(fill="x", padx=10, pady=8)

        self.btn_poll = tk.Button(
            self.buttons_frame, text="â–¶ Start polling",
            font=("Segoe UI", f_ui),
            command=self.toggle_polling
        )
        self.btn_poll.pack(side="left", padx=6)

        self.btn_sync = tk.Button(
            self.buttons_frame, text="âš¡ Sync now",
            font=("Segoe UI", f_ui),
            command=self.manual_sync
        )
        self.btn_sync.pack(side="left", padx=6)

        self.btn_merge = tk.Button(
            self.buttons_frame, text="ğŸ”€ Merge (fichiers disjoints)",
            font=("Segoe UI", f_ui),
            command=self.manual_merge,
            bg="#ffcc00"
        )

        # LOG SECTION (collapsible)
        self.log_header = ttk.Frame(self)
        self.log_header.pack(fill="x", padx=10, pady=(10, 0))

        self.toggle_arrow = tk.StringVar(value="â–¼")
        self.btn_toggle_log = tk.Button(
            self.log_header,
            textvariable=self.toggle_arrow,
            font=("Segoe UI", f_ui),
            width=2,
            relief="flat",
            command=self.toggle_log
        )
        self.btn_toggle_log.pack(side="left")

        tk.Label(
            self.log_header,
            text="Log",
            font=("Segoe UI", f_ui, "bold")
        ).pack(side="left", padx=4)

        # LOG
        self.log_frame = ttk.Frame(self)
        self.log_frame.pack(fill="both", expand=True, padx=10, pady=6)

        self.log = ScrolledText(self.log_frame, state="disabled",
                                font=("Consolas", f_log), height=15)
        self.log.pack(fill="both", expand=True)
        self.log.bind("<Control-a>", self.select_all)

        # DÃ‰MARRAGE
        threading.Thread(target=self.initial_scan, daemon=True).start()

    # --------------------------------------------------------
    # GIT HEALTH & TAB STATE
    # --------------------------------------------------------

    def check_and_update_health(self):
        """VÃ©rifie la santÃ© Git et met Ã  jour l'Ã©tat de l'onglet."""
        ok, err = check_git_health(self.repo_path, self.remote, self.main, self.git)
        self.git_healthy = ok
        self.git_error = err

        if not ok:
            self.disable_tab(err)
        else:
            self.enable_tab()

        return ok

    def disable_tab(self, error_msg):
        """DÃ©sactive les contrÃ´les de l'onglet avec un message d'erreur."""
        self.state_var.set("ğŸ”´ ERREUR â€” Git non fonctionnel")
        self.info_var.set(error_msg)
        self.btn_poll.config(state="disabled")
        self.btn_sync.config(state="disabled")
        self.polling = False
        self.btn_poll.config(text="â–¶ Start polling")
        # Mettre Ã  jour l'indicateur de l'onglet (rouge pour erreur)
        self.after(0, lambda: self.app.update_tab_name(self))

    def enable_tab(self):
        """RÃ©active les contrÃ´les de l'onglet."""
        self.btn_poll.config(state="normal")
        self.btn_sync.config(state="normal")

    # --------------------------------------------------------
    # CONFIG DIALOG
    # --------------------------------------------------------

    def show_config_dialog(self):
        """Affiche le dialogue de configuration du repo."""
        dialog = tk.Toplevel(self.app)
        dialog.title(f"Configuration â€” {self.repo_path.name}")
        dialog.geometry("400x280")
        dialog.transient(self.app)
        dialog.grab_set()
        dialog.resizable(False, False)

        f_ui = self.f_ui

        # Frame principale
        main_frame = ttk.Frame(dialog, padding=15)
        main_frame.pack(fill="both", expand=True)

        # Remote
        ttk.Label(main_frame, text="Remote:", font=("Segoe UI", f_ui)).grid(
            row=0, column=0, sticky="w", pady=5)
        remote_var = tk.StringVar(value=self.remote)
        ttk.Entry(main_frame, textvariable=remote_var, font=("Segoe UI", f_ui),
                 width=25).grid(row=0, column=1, sticky="ew", pady=5, padx=(10, 0))

        # Main branch
        ttk.Label(main_frame, text="Main branch:", font=("Segoe UI", f_ui)).grid(
            row=1, column=0, sticky="w", pady=5)
        main_var = tk.StringVar(value=self.main)
        ttk.Entry(main_frame, textvariable=main_var, font=("Segoe UI", f_ui),
                 width=25).grid(row=1, column=1, sticky="ew", pady=5, padx=(10, 0))

        # Branch prefix
        ttk.Label(main_frame, text="Branch prefix:", font=("Segoe UI", f_ui)).grid(
            row=2, column=0, sticky="w", pady=5)
        prefix_var = tk.StringVar(value=self.prefix)
        ttk.Entry(main_frame, textvariable=prefix_var, font=("Segoe UI", f_ui),
                 width=25).grid(row=2, column=1, sticky="ew", pady=5, padx=(10, 0))

        # Interval
        ttk.Label(main_frame, text="Interval (sec):", font=("Segoe UI", f_ui)).grid(
            row=3, column=0, sticky="w", pady=5)
        interval_var = tk.IntVar(value=self.interval)
        ttk.Spinbox(main_frame, textvariable=interval_var, from_=5, to=3600,
                   font=("Segoe UI", f_ui), width=10).grid(
            row=3, column=1, sticky="w", pady=5, padx=(10, 0))

        main_frame.columnconfigure(1, weight=1)

        # Buttons
        btn_frame = ttk.Frame(dialog)
        btn_frame.pack(fill="x", padx=15, pady=15)

        def save_config():
            self.remote = remote_var.get().strip()
            self.main = main_var.get().strip()
            self.prefix = prefix_var.get().strip()
            self.interval = interval_var.get()

            self.repo_config = {
                "remote": self.remote,
                "main_branch": self.main,
                "branch_prefix": self.prefix,
                "interval_seconds": self.interval
            }

            try:
                save_repo_config(self.repo_path, self.repo_config)
                self.log_msg("âœ… Configuration sauvegardÃ©e")
                self.app.update_repo_menu()
                # RevÃ©rifier la santÃ© Git avec les nouveaux paramÃ¨tres
                self.check_and_update_health()
            except Exception as e:
                messagebox.showerror("Erreur", f"Impossible de sauvegarder: {e}", parent=dialog)
                return

            dialog.destroy()

        tk.Button(btn_frame, text="Sauvegarder", font=("Segoe UI", f_ui),
                 command=save_config).pack(side="left", padx=5)
        tk.Button(btn_frame, text="Annuler", font=("Segoe UI", f_ui),
                 command=dialog.destroy).pack(side="left", padx=5)

    def open_folder(self):
        """Ouvre le dossier du repo dans le gestionnaire de fichiers."""
        try:
            subprocess.run(["xdg-open", str(self.repo_path)],
                          stderr=subprocess.DEVNULL, stdout=subprocess.DEVNULL)
        except:
            pass

    def delete_branch(self, branch_name):
        """Supprime une branche remote aprÃ¨s confirmation."""
        if not messagebox.askyesno(
            "Confirmer suppression",
            f"Supprimer la branche remote '{branch_name}' ?\n\nCette action est irrÃ©versible.",
            parent=self
        ):
            return

        self.log_msg(f"Suppression de {branch_name}â€¦")
        success, err = delete_remote_branch(branch_name, self.remote,
                                           cwd=self.repo_path, git=self.git)

        if success:
            self.log_msg(f"âœ… Branche {branch_name} supprimÃ©e")
            self.app.update_repo_menu()
            self.manual_sync()
        else:
            self.log_msg(f"âŒ Erreur: {err}")

    # --------------------------------------------------------
    # TOGGLE LOG
    # --------------------------------------------------------

    def toggle_log(self):
        if self.log_visible:
            self.log_frame.pack_forget()
            self.toggle_arrow.set("â–¶")
        else:
            self.log_frame.pack(fill="both", expand=True, padx=10, pady=6)
            self.toggle_arrow.set("â–¼")
        self.log_visible = not self.log_visible

    # --------------------------------------------------------
    # MERGE BUTTON VISIBILITY
    # --------------------------------------------------------

    def show_merge_button(self):
        self.btn_merge.pack(side="left", padx=6)

    def hide_merge_button(self):
        self.btn_merge.pack_forget()

    # --------------------------------------------------------
    # POLLING CONTROL
    # --------------------------------------------------------

    def stop_polling(self):
        """ArrÃªte le polling et met Ã  jour le bouton et l'indicateur."""
        self.polling = False
        self.btn_poll.config(text="â–¶ Start polling")
        self.stop_countdown()
        # Mettre Ã  jour l'indicateur de l'onglet (peut passer en rouge si STOP)
        self.after(0, lambda: self.app.update_tab_name(self))

    def _mark_if_not_active(self):
        """Marque l'onglet si ce n'est pas l'onglet actif."""
        try:
            current_tab = self.app.notebook.select()
            if current_tab != self:
                self.app.mark_tab_updated(self)
        except tk.TclError:
            pass

    # --------------------------------------------------------
    # LOGGING
    # --------------------------------------------------------

    def log_msg(self, txt):
        ts = datetime.now().strftime("%H:%M:%S")
        self.log.configure(state="normal")
        self.log.insert("end", f"[{ts}] {txt}\n")
        self.log.see("end")
        self.log.configure(state="disabled")

    def select_all(self, _):
        self.log.tag_add("sel", "1.0", "end")
        return "break"

    def export_log(self):
        """Exporte le log vers un fichier."""
        filename = filedialog.asksaveasfilename(
            title="Exporter le log",
            defaultextension=".txt",
            initialfile=f"githerd-{self.repo_path.name}-{datetime.now().strftime('%Y%m%d-%H%M%S')}.txt",
            filetypes=[("Fichiers texte", "*.txt"), ("Tous les fichiers", "*.*")]
        )
        if filename:
            try:
                content = self.log.get("1.0", "end")
                with open(filename, "w") as f:
                    f.write(f"GitHerd Log - {self.repo_path}\n")
                    f.write(f"Exported: {datetime.now()}\n")
                    f.write("=" * 50 + "\n\n")
                    f.write(content)
                self.log_msg(f"âœ… Log exportÃ© vers {filename}")
            except Exception as e:
                messagebox.showerror("Erreur", f"Impossible d'exporter: {e}", parent=self)

    # --------------------------------------------------------
    # COUNTDOWN
    # --------------------------------------------------------

    def start_countdown(self):
        """DÃ©marre le countdown jusqu'au prochain poll."""
        self.update_countdown()

    def stop_countdown(self):
        """ArrÃªte le countdown."""
        if self.countdown_job:
            self.after_cancel(self.countdown_job)
            self.countdown_job = None
        self.countdown_var.set("")

    def update_countdown(self):
        """Met Ã  jour l'affichage du countdown."""
        if not self.polling:
            self.countdown_var.set("")
            return

        remaining = int(self.next_poll_time - time.time())
        if remaining > 0:
            self.countdown_var.set(f"(prochain sync: {remaining}s)")
        else:
            self.countdown_var.set("(sync...)")

        self.countdown_job = self.after(1000, self.update_countdown)

    # --------------------------------------------------------
    # PUSH ALL BRANCHES
    # --------------------------------------------------------

    def push_main_and_branches(self):
        """Push main vers origin et sync toutes les branches."""
        self.log_msg(f"git push {self.remote} {self.main}")
        code, out, err = run_git([self.git, "push", self.remote, self.main],
                                cwd=self.repo_path)
        if code != 0:
            self.log_msg(f"ERREUR push main: {err}")
            self.state_var.set("ğŸ”´ ERREUR")
            self.stop_polling()
            return False
        self.log_msg(out if out else "  (ok)")

        branches = get_tracked_branches(self.remote, self.prefix,
                                        cwd=self.repo_path, git=self.git)
        for b in branches:
            target = b.replace(f"{self.remote}/", "")
            refspec = f"{self.main}:{target}"
            self.log_msg(f"git push {self.remote} {refspec}")
            code, out, err = run_git([self.git, "push", self.remote, refspec],
                                    cwd=self.repo_path)
            if code != 0:
                self.log_msg(f"ERREUR push {target}: {err}")
                self.state_var.set("ğŸ”´ STOP â€” Push failed")
                self.info_var.set(f"Push vers {target} a Ã©chouÃ©")
                self.stop_polling()
                return False
            self.log_msg(out if out else "  (ok)")

        return True

    # --------------------------------------------------------
    # CORE LOGIC
    # --------------------------------------------------------

    def sync(self):
        if not self.lock.acquire(blocking=False):
            return
        try:
            self._do_sync()
        finally:
            self.lock.release()

    def _do_sync(self):
        self.state_var.set("ğŸ”„ Syncâ€¦")
        self.hide_merge_button()
        self.pending_branches = []

        self.log_msg(f"git fetch {self.remote}")
        code, _, err = run_git([self.git, "fetch", self.remote], cwd=self.repo_path)
        if code != 0:
            self.log_msg(f"ERREUR fetch: {err}")
            self.state_var.set("ğŸ”´ ERREUR")
            self.stop_polling()
            return

        self.app.update_repo_menu()

        local_ahead = local_main_ahead(self.remote, self.main,
                                       cwd=self.repo_path, git=self.git)
        if local_ahead > 0:
            self.log_msg(f"main local en avance de {local_ahead} commits â†’ push")
            if self.push_main_and_branches():
                self.state_var.set("ğŸŸ¢ Sync OK")
                self.info_var.set(f"Push de {local_ahead} commits locaux")
                self.log_msg("âœ… Push terminÃ© avec succÃ¨s")
            return

        branches = get_tracked_branches(self.remote, self.prefix,
                                        cwd=self.repo_path, git=self.git)
        self.log_msg(f"Branches {self.prefix}*: {len(branches)}")

        ahead_branches = []
        diverged_branches = []
        new_commits_detected = False

        for b in branches:
            ahead = commits_ahead(f"{self.remote}/{self.main}", b,
                                 cwd=self.repo_path, git=self.git)
            behind = commits_behind(f"{self.remote}/{self.main}", b,
                                   cwd=self.repo_path, git=self.git)

            if ahead > 0:
                short_name = b.replace(f"{self.remote}/", "")

                if behind > 0:
                    diverged_branches.append((short_name, ahead, behind))
                    self.log_msg(f"  {short_name}: +{ahead}/-{behind} (DIVERGÃ‰E)")
                else:
                    ahead_branches.append((short_name, ahead))
                    self.log_msg(f"  {short_name}: +{ahead} commits")

                prev = self.last_commit_count.get(short_name, 0)
                if ahead > prev:
                    new_commits_detected = True
                self.last_commit_count[short_name] = ahead

        if new_commits_detected:
            self.log_msg("ğŸ”” Nouveau commit dÃ©tectÃ©!")
            threading.Thread(target=lambda: play_sound("commit"), daemon=True).start()
            # Notification desktop
            if self.app.global_settings.get("desktop_notifications", True):
                send_notification(
                    f"GitHerd â€” {self.repo_path.name}",
                    "Nouveau commit dÃ©tectÃ©!",
                    "normal"
                )
            # Marquer l'onglet si ce n'est pas l'onglet actif
            self.after(0, self._mark_if_not_active)

        total_problematic = len(ahead_branches) + len(diverged_branches)

        if total_problematic == 0:
            # VÃ©rifier si des branches sont en retard sur origin/main
            behind_branches = []
            for b in branches:
                behind = commits_behind(f"{self.remote}/{self.main}", b,
                                       cwd=self.repo_path, git=self.git)
                if behind > 0:
                    short_name = b.replace(f"{self.remote}/", "")
                    behind_branches.append((short_name, behind))
                    self.log_msg(f"  {short_name}: -{behind} commits (en retard)")

            if behind_branches:
                self.log_msg(f"Synchronisation de {len(behind_branches)} branches en retardâ€¦")
                for branch_name, _ in behind_branches:
                    refspec = f"{self.main}:{branch_name}"
                    self.log_msg(f"git push {self.remote} {refspec}")
                    code, out, err = run_git(
                        [self.git, "push", self.remote, refspec],
                        cwd=self.repo_path
                    )
                    if code != 0:
                        self.log_msg(f"ERREUR push {branch_name}: {err}")
                        self.state_var.set("ğŸ”´ ERREUR")
                        self.stop_polling()
                        return
                    self.log_msg(out if out else "  (ok)")

                self.state_var.set("ğŸŸ¢ Sync OK")
                self.info_var.set(f"{len(behind_branches)} branches synchronisÃ©es")
                self.log_msg("âœ… Branches en retard synchronisÃ©es")
                return

            self.state_var.set("ğŸŸ¢ Idle")
            self.info_var.set("Toutes les branches sont synchronisÃ©es")
            self.log_msg("âœ“ Rien Ã  faire")
            self.last_commit_count.clear()
            return

        if len(diverged_branches) > 0 or len(ahead_branches) > 1:
            all_names = [b[0] for b in diverged_branches] + [b[0] for b in ahead_branches]
            self.pending_branches = all_names

            self.log_msg("VÃ©rification des fichiers modifiÃ©sâ€¦")
            disjoint = are_files_disjoint(all_names, f"{self.remote}/{self.main}",
                                         self.remote, cwd=self.repo_path, git=self.git)

            if len(diverged_branches) > 0:
                diverged_names = [f"{b[0]} (+{b[1]}/-{b[2]})" for b in diverged_branches]
                msg = f"Branches divergÃ©es: {', '.join(diverged_names)}"
            else:
                msg = f"Plusieurs branches: {', '.join(all_names)}"

            if disjoint:
                self.state_var.set("ğŸŸ¡ STOP â€” Merge possible")
                self.info_var.set(f"Fichiers disjoints. {msg}")
                self.log_msg("âœ“ Fichiers disjoints â€” merge manuel possible")
                self.show_merge_button()
            else:
                self.state_var.set("ğŸ”´ STOP â€” Action humaine requise")
                self.info_var.set(f"Fichiers en conflit potentiel. {msg}")
                self.log_msg("â›” STOP: fichiers en commun dÃ©tectÃ©s")
            self.stop_polling()
            return

        leader, _ = ahead_branches[0]
        self.log_msg(f"git pull --ff-only {self.remote} {leader}")
        code, out, err = run_git(
            [self.git, "pull", "--ff-only", self.remote, leader],
            cwd=self.repo_path
        )
        if code != 0:
            self.log_msg(f"ERREUR pull: {err}")
            self.state_var.set("ğŸ”´ ERREUR")
            self.info_var.set(f"Pull failed: {err[:100]}")
            self.stop_polling()
            return
        self.log_msg(out if out else "  (ok)")

        if not self.push_main_and_branches():
            return

        self.last_commit_count[leader] = 0
        self.state_var.set("ğŸŸ¢ Sync OK")
        branches = get_tracked_branches(self.remote, self.prefix,
                                        cwd=self.repo_path, git=self.git)
        other_count = len(branches) - 1
        self.info_var.set(f"Pull de {leader}, push vers {other_count} autres branches")
        self.log_msg("âœ… Sync terminÃ© avec succÃ¨s")

    # --------------------------------------------------------
    # MANUAL MERGE (fichiers disjoints)
    # --------------------------------------------------------

    def manual_merge(self):
        threading.Thread(target=self._do_merge, daemon=True).start()

    def _do_merge(self):
        if not self.lock.acquire(blocking=False):
            return
        try:
            self._do_merge_impl()
        finally:
            self.lock.release()

    def _do_merge_impl(self):
        if not self.pending_branches:
            self.log_msg("Aucune branche en attente de merge")
            return

        self.state_var.set("ğŸ”€ Merge en coursâ€¦")
        self.hide_merge_button()

        branches = self.pending_branches[:]
        self.log_msg(f"Merge de {len(branches)} branches: {', '.join(branches)}")

        for branch in branches:
            self.log_msg(f"git merge {self.remote}/{branch}")
            code, out, err = run_git(
                [self.git, "merge", f"{self.remote}/{branch}", "-m", f"Merge {branch}"],
                cwd=self.repo_path
            )
            if code != 0:
                self.log_msg(f"ERREUR merge {branch}: {err}")
                self.state_var.set("ğŸ”´ ERREUR â€” Merge Ã©chouÃ©")
                self.info_var.set(f"Merge de {branch} a Ã©chouÃ©")
                run_git([self.git, "merge", "--abort"], cwd=self.repo_path)
                self.stop_polling()
                return
            self.log_msg(out if out else "  (ok)")

        if not self.push_main_and_branches():
            return

        self.pending_branches = []
        self.last_commit_count.clear()
        self.state_var.set("ğŸŸ¢ Merge OK")
        self.info_var.set(f"Merge de {len(branches)} branches terminÃ©")
        self.log_msg("âœ… Merge terminÃ© avec succÃ¨s")

        # Mettre Ã  jour l'indicateur de l'onglet (retour Ã  gris)
        self.after(0, lambda: self.app.update_tab_name(self))
        self.app.update_repo_menu()

    # --------------------------------------------------------
    # INITIAL SCAN (read-only)
    # --------------------------------------------------------

    def initial_scan(self):
        # D'abord vÃ©rifier la santÃ© Git
        if not self.check_and_update_health():
            self.log_msg(f"âŒ {self.git_error}")
            return

        try:
            run_git([self.git, "fetch", self.remote], cwd=self.repo_path)

            self.app.update_repo_menu()

            local_ahead = local_main_ahead(self.remote, self.main,
                                          cwd=self.repo_path, git=self.git)
            if local_ahead > 0:
                self.state_var.set("ğŸŸ¡ main local en avance")
                self.info_var.set(f"+{local_ahead} commits Ã  pusher â€” cliquer Sync now")
                return

            branches = get_tracked_branches(self.remote, self.prefix,
                                           cwd=self.repo_path, git=self.git)

            ahead_list = []
            diverged_list = []

            for b in branches:
                ahead = commits_ahead(f"{self.remote}/{self.main}", b,
                                     cwd=self.repo_path, git=self.git)
                behind = commits_behind(f"{self.remote}/{self.main}", b,
                                       cwd=self.repo_path, git=self.git)

                if ahead > 0:
                    short_name = b.replace(f"{self.remote}/", "")
                    self.last_commit_count[short_name] = ahead

                    if behind > 0:
                        diverged_list.append((short_name, ahead, behind))
                    else:
                        ahead_list.append(short_name)

            total = len(ahead_list) + len(diverged_list)

            if total == 0:
                # VÃ©rifier si des branches sont en retard
                behind_list = []
                for b in branches:
                    behind = commits_behind(f"{self.remote}/{self.main}", b,
                                           cwd=self.repo_path, git=self.git)
                    if behind > 0:
                        short_name = b.replace(f"{self.remote}/", "")
                        behind_list.append((short_name, behind))

                if behind_list:
                    names = [f"{b[0]} (-{b[1]})" for b in behind_list]
                    self.state_var.set("ğŸŸ¡ Branches en retard")
                    self.info_var.set(f"Ã€ synchroniser: {', '.join(names)}")
                else:
                    self.state_var.set("ğŸŸ¢ Idle")
                    self.info_var.set("Toutes les branches sont synchronisÃ©es")
            elif len(diverged_list) == 0 and len(ahead_list) == 1:
                self.state_var.set("ğŸŸ¡ 1 branche en avance")
                self.info_var.set(f"PrÃªt Ã  sync: {ahead_list[0]}")
            else:
                all_names = [b[0] for b in diverged_list] + ahead_list
                self.pending_branches = all_names

                disjoint = are_files_disjoint(all_names, f"{self.remote}/{self.main}",
                                             self.remote, cwd=self.repo_path, git=self.git)

                if len(diverged_list) > 0:
                    diverged_info = [f"{b[0]} (+{b[1]}/-{b[2]})" for b in diverged_list]
                    msg = f"DivergÃ©es: {', '.join(diverged_info)}"
                else:
                    msg = f"Plusieurs branches: {', '.join(all_names)}"

                if disjoint:
                    self.state_var.set("ğŸŸ¡ STOP â€” Merge possible")
                    self.info_var.set(f"Fichiers disjoints. {msg}")
                    self.after(100, self.show_merge_button)
                else:
                    self.state_var.set("ğŸ”´ STOP â€” Action humaine requise")
                    self.info_var.set(msg)

                # Mettre Ã  jour l'indicateur de l'onglet (rouge pour STOP)
                self.after(0, lambda: self.app.update_tab_name(self))

        except Exception as e:
            self.state_var.set("ğŸ”´ ERREUR")
            self.info_var.set(str(e))
            # Mettre Ã  jour l'indicateur de l'onglet
            self.after(0, lambda: self.app.update_tab_name(self))

    # --------------------------------------------------------
    # POLLING
    # --------------------------------------------------------

    def polling_loop(self):
        next_tick = time.time()
        while self.polling:
            self.sync()
            # Recharger l'interval depuis la config
            try:
                cfg = load_repo_config(self.repo_path)
                interval = cfg.get("interval_seconds", self.interval)
            except:
                interval = self.interval

            next_tick += interval
            self.next_poll_time = next_tick
            sleep_time = max(0, next_tick - time.time())
            time.sleep(sleep_time)

    def toggle_polling(self):
        if not self.git_healthy:
            return
        self.polling = not self.polling
        self.btn_poll.config(
            text="â¸ Stop polling" if self.polling else "â–¶ Start polling"
        )
        if self.polling:
            self.next_poll_time = time.time() + self.interval
            self.start_countdown()
            threading.Thread(target=self.polling_loop, daemon=True).start()
        else:
            self.stop_countdown()
        self.app.update_tab_name(self)
        self.app.update_title()
        self.app.update_repo_menu()

    def manual_sync(self):
        if not self.git_healthy:
            return
        threading.Thread(target=self.sync, daemon=True).start()


# ============================================================
# CUSTOM NOTEBOOK (avec backgrounds colorÃ©s par onglet)
# ============================================================

class CustomNotebook(tk.Frame):
    """Notebook personnalisÃ© permettant des backgrounds colorÃ©s par onglet."""

    # Couleurs
    BG_DEFAULT = "#E0E0E0"      # Gris standard
    BG_SELECTED = "#FFFFFF"     # Blanc pour l'onglet sÃ©lectionnÃ©
    BG_GREEN = "#90EE90"        # Vert pastel (polling actif)
    BG_RED = "#FFB6C1"          # Rouge pastel (STOP/erreur)

    def __init__(self, parent, **kwargs):
        super().__init__(parent, **kwargs)

        self.tab_frames = []      # Liste des frames de contenu
        self.tab_labels = []      # Liste des labels d'onglet
        self.tab_data = []        # DonnÃ©es par onglet: {text, bg_state, has_update}
        self.selected_index = -1
        self.font_zoom = 1.6

        # Frame pour les onglets (en haut)
        self.tab_bar = tk.Frame(self, bg="#C0C0C0")
        self.tab_bar.pack(fill="x", side="top")

        # Container pour le contenu
        self.content = tk.Frame(self)
        self.content.pack(fill="both", expand=True, side="top")

    def set_font_zoom(self, zoom):
        """DÃ©finit le facteur de zoom pour les onglets."""
        self.font_zoom = zoom

    def add(self, frame, text="", **kwargs):
        """Ajoute un onglet."""
        index = len(self.tab_frames)

        # CrÃ©er le label de l'onglet
        f_tab = int(10 * self.font_zoom)
        label = tk.Label(
            self.tab_bar,
            text=text,
            font=("Segoe UI", f_tab),
            padx=12,
            pady=6,
            bg=self.BG_DEFAULT,
            relief="raised",
            cursor="hand2"
        )
        label.pack(side="left", padx=1, pady=2)

        # Bindings
        label.bind("<Button-1>", lambda e, i=index: self._select_by_index(i))
        label.bind("<Button-3>", lambda e, i=index: self._on_right_click(e, i))

        # Stocker les donnÃ©es
        self.tab_frames.append(frame)
        self.tab_labels.append(label)
        self.tab_data.append({
            "text": text,
            "bg_state": "default",  # default, green, red
            "has_update": False
        })

        # Placer le frame dans le container (cachÃ© par dÃ©faut)
        frame.place(in_=self.content, x=0, y=0, relwidth=1, relheight=1)

        # SÃ©lectionner si c'est le premier onglet
        if self.selected_index == -1:
            self._select_by_index(0)
        else:
            frame.lower()

        return index

    def select(self, tab_or_index=None):
        """SÃ©lectionne un onglet ou retourne l'onglet sÃ©lectionnÃ©."""
        if tab_or_index is None:
            # Retourner l'onglet sÃ©lectionnÃ©
            if 0 <= self.selected_index < len(self.tab_frames):
                return self.tab_frames[self.selected_index]
            return None

        if isinstance(tab_or_index, int):
            index = tab_or_index
        else:
            # C'est un frame
            try:
                index = self.tab_frames.index(tab_or_index)
            except ValueError:
                return
        self._select_by_index(index)

    def _select_by_index(self, index):
        """SÃ©lectionne l'onglet par index."""
        if index < 0 or index >= len(self.tab_frames):
            return

        # DÃ©sÃ©lectionner l'ancien
        if self.selected_index >= 0 and self.selected_index < len(self.tab_labels):
            old_label = self.tab_labels[self.selected_index]
            old_data = self.tab_data[self.selected_index]
            old_label.config(relief="raised", bg=self._get_bg_color(old_data["bg_state"]))
            self.tab_frames[self.selected_index].lower()

        # SÃ©lectionner le nouveau
        self.selected_index = index
        new_label = self.tab_labels[index]
        new_data = self.tab_data[index]

        # L'onglet sÃ©lectionnÃ© a un fond plus clair
        selected_bg = self._get_selected_bg_color(new_data["bg_state"])
        new_label.config(relief="sunken", bg=selected_bg)
        self.tab_frames[index].lift()

        # Ã‰mettre l'Ã©vÃ©nement
        self.event_generate("<<NotebookTabChanged>>")

    def _get_bg_color(self, bg_state):
        """Retourne la couleur de fond selon l'Ã©tat."""
        if bg_state == "green":
            return self.BG_GREEN
        elif bg_state == "red":
            return self.BG_RED
        return self.BG_DEFAULT

    def _get_selected_bg_color(self, bg_state):
        """Retourne la couleur de fond pour un onglet sÃ©lectionnÃ©."""
        if bg_state == "green":
            return "#B0FFB0"  # Vert plus clair
        elif bg_state == "red":
            return "#FFD0D8"  # Rouge plus clair
        return self.BG_SELECTED

    def forget(self, tab):
        """Supprime un onglet."""
        try:
            index = self.tab_frames.index(tab)
        except ValueError:
            return

        # Supprimer le label
        self.tab_labels[index].destroy()

        # Supprimer le frame du container
        self.tab_frames[index].place_forget()

        # Supprimer des listes
        del self.tab_frames[index]
        del self.tab_labels[index]
        del self.tab_data[index]

        # Mettre Ã  jour les bindings des labels restants
        for i, label in enumerate(self.tab_labels):
            label.bind("<Button-1>", lambda e, idx=i: self._select_by_index(idx))
            label.bind("<Button-3>", lambda e, idx=i: self._on_right_click(e, idx))

        # Ajuster la sÃ©lection
        if len(self.tab_frames) == 0:
            self.selected_index = -1
        elif self.selected_index >= len(self.tab_frames):
            self._select_by_index(len(self.tab_frames) - 1)
        elif self.selected_index == index:
            self._select_by_index(max(0, index - 1) if index > 0 else 0)
        elif self.selected_index > index:
            self.selected_index -= 1

    def tabs(self):
        """Retourne la liste des frames d'onglet."""
        return self.tab_frames[:]

    def index(self, what):
        """Retourne l'index d'un onglet."""
        if what == "current" or what == self.select():
            return self.selected_index
        if isinstance(what, str) and what.startswith("@"):
            # Format @x,y - trouver l'onglet sous les coordonnÃ©es
            try:
                coords = what[1:].split(",")
                x, y = int(coords[0]), int(coords[1])
                for i, label in enumerate(self.tab_labels):
                    lx = label.winfo_x()
                    ly = label.winfo_y()
                    lw = label.winfo_width()
                    lh = label.winfo_height()
                    if lx <= x <= lx + lw and ly <= y <= ly + lh:
                        return i
            except:
                pass
            raise tk.TclError("bad tab index")
        try:
            return self.tab_frames.index(what)
        except ValueError:
            raise tk.TclError("bad tab index")

    def tab(self, tab, **kwargs):
        """Configure ou retourne les options d'un onglet."""
        try:
            if isinstance(tab, int):
                index = tab
            else:
                index = self.tab_frames.index(tab)
        except (ValueError, IndexError):
            return

        if not kwargs:
            return self.tab_data[index]

        # Mettre Ã  jour les options
        data = self.tab_data[index]
        label = self.tab_labels[index]

        if "text" in kwargs:
            data["text"] = kwargs["text"]
            label.config(text=kwargs["text"])

        if "bg_state" in kwargs:
            data["bg_state"] = kwargs["bg_state"]
            if index == self.selected_index:
                label.config(bg=self._get_selected_bg_color(data["bg_state"]))
            else:
                label.config(bg=self._get_bg_color(data["bg_state"]))

    def nametowidget(self, name):
        """Retourne le widget correspondant au nom."""
        # Pour compatibilitÃ© avec l'ancien code
        if isinstance(name, int) and 0 <= name < len(self.tab_frames):
            return self.tab_frames[name]
        for frame in self.tab_frames:
            if str(frame) == name:
                return frame
        return None

    def _on_right_click(self, event, index):
        """GÃ¨re le clic droit sur un onglet."""
        # CrÃ©er un Ã©vÃ©nement avec les coordonnÃ©es pour le handler externe
        event.widget = self
        event.tab_index = index
        self.event_generate("<<TabRightClick>>", x=event.x_root, y=event.y_root)


# ============================================================
# MAIN APP
# ============================================================

class App(tk.Tk):
    def __init__(self):
        super().__init__()

        self.tabs = {}  # repo_path -> RepoTab
        self.global_settings = load_global_settings()
        self.font_zoom = self.global_settings.get("font_zoom", 1.6)

        self.title("GitHerd")
        self.geometry("1000x700")

        # Tailles de police calculÃ©es
        f_ui = int(11 * self.font_zoom)
        f_tab = int(10 * self.font_zoom)

        # Police par dÃ©faut pour dialogues systÃ¨me
        self.option_add("*Dialog.msg.font", f"Segoe\\ UI {f_ui}")
        self.option_add("*TkFDialog*font", f"Segoe\\ UI {f_ui}")
        self.option_add("*Font", f"Segoe\\ UI {f_ui}")

        # Style global
        style = ttk.Style()
        style.configure("TLabel", font=("Segoe UI", f_ui))
        style.configure("TButton", font=("Segoe UI", f_ui))
        style.configure("TEntry", font=("Segoe UI", f_ui))

        # MENU BAR
        self.menubar = tk.Menu(self, font=("Segoe UI", f_ui))
        self.config(menu=self.menubar)
        self.f_ui = f_ui

        # Menu Fichier
        file_menu = tk.Menu(self.menubar, tearoff=0, font=("Segoe UI", f_ui))
        self.menubar.add_cascade(label="Fichier", menu=file_menu)
        file_menu.add_command(label="Ajouter un repo...", command=self.add_repo_dialog,
                             accelerator="Ctrl+O")
        file_menu.add_command(label="Stopper tous les polling", command=self.stop_all_polling,
                             accelerator="Ctrl+S")
        file_menu.add_separator()
        file_menu.add_command(label="RedÃ©marrer", command=self.restart_app,
                             accelerator="Ctrl+R")
        file_menu.add_command(label="Quitter", command=self.on_close, accelerator="Ctrl+Q")

        # Menu Repository (dynamique selon l'onglet actif)
        self.repo_menu = tk.Menu(self.menubar, tearoff=0, font=("Segoe UI", f_ui))
        self.menubar.add_cascade(label="Repository", menu=self.repo_menu)

        # Menu Options
        config_menu = tk.Menu(self.menubar, tearoff=0, font=("Segoe UI", f_ui))
        self.menubar.add_cascade(label="Options", menu=config_menu)
        config_menu.add_command(label="ParamÃ¨tres globaux...", command=self.show_global_settings)

        # Menu Aide
        help_menu = tk.Menu(self.menubar, tearoff=0, font=("Segoe UI", f_ui))
        self.menubar.add_cascade(label="Aide", menu=help_menu)
        help_menu.add_command(label="Ã€ propos de GitHerd", command=self.show_help)

        # Raccourcis clavier
        self.bind("<Control-o>", lambda e: self.add_repo_dialog())
        self.bind("<Control-s>", lambda e: self.stop_all_polling())
        self.bind("<Control-r>", lambda e: self.restart_app())
        self.bind("<Control-q>", lambda e: self.on_close())
        self.bind("<Control-Tab>", lambda e: self.next_tab())
        self.bind("<Control-Shift-Tab>", lambda e: self.prev_tab())
        self.bind("<Control-ISO_Left_Tab>", lambda e: self.prev_tab())  # Linux
        self.bind("<Control-m>", lambda e: self.toggle_compact_mode())

        # NOTEBOOK (onglets avec backgrounds colorÃ©s)
        self.notebook = CustomNotebook(self)
        self.notebook.set_font_zoom(self.font_zoom)
        self.notebook.pack(fill="both", expand=True, padx=5, pady=5)

        # Bind right-click pour fermer un onglet
        self.notebook.bind("<<TabRightClick>>", self.on_tab_right_click)

        # Bind tab change pour effacer le marqueur
        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_changed)

        # Charger les repos sauvegardÃ©s
        self.load_saved_repos()

        # Si aucun repo, ouvrir le dialogue
        if not self.tabs:
            self.after(100, self.add_repo_dialog)

        # Initialiser le menu Repo
        self.after(200, self.update_repo_menu)

        # Sauvegarder Ã  la fermeture
        self.protocol("WM_DELETE_WINDOW", self.on_close)

        # ALWAYS ON TOP
        self.after(500, self.set_always_on_top)

    def set_always_on_top(self):
        self.attributes("-topmost", True)
        try:
            subprocess.run(
                ["wmctrl", "-r", self.title(), "-b", "add,above"],
                stderr=subprocess.DEVNULL,
                stdout=subprocess.DEVNULL
            )
        except FileNotFoundError:
            pass

    # --------------------------------------------------------
    # TAB BACKGROUND STATE
    # --------------------------------------------------------

    def get_tab_bg_state(self, tab):
        """Retourne l'Ã©tat de background pour l'onglet (green, red, default)."""
        # Rouge si erreur Git ou Ã©tat STOP
        if not tab.git_healthy:
            return "red"

        # VÃ©rifier si en Ã©tat STOP (pending_branches non vide et pas de polling)
        if tab.pending_branches and not tab.polling:
            return "red"

        # Vert si polling actif
        if tab.polling:
            return "green"

        # DÃ©faut sinon
        return "default"

    # --------------------------------------------------------
    # GLOBAL SETTINGS DIALOG
    # --------------------------------------------------------

    def show_global_settings(self):
        """Affiche le dialogue des paramÃ¨tres globaux."""
        f_ui = int(11 * self.font_zoom)

        dialog = tk.Toplevel(self)
        dialog.title("ParamÃ¨tres globaux")
        dialog.geometry(f"{int(500 * self.font_zoom)}x{int(320 * self.font_zoom)}")
        dialog.transient(self)
        dialog.grab_set()
        dialog.resizable(False, False)

        # Frame principale
        main_frame = ttk.Frame(dialog, padding=15)
        main_frame.pack(fill="both", expand=True)

        row = 0

        # Git binary
        ttk.Label(main_frame, text="Git binary:", font=("Segoe UI", f_ui)).grid(
            row=row, column=0, sticky="w", pady=6)
        git_var = tk.StringVar(value=self.global_settings.get("git_binary", "git"))
        git_entry = ttk.Entry(main_frame, textvariable=git_var, font=("Segoe UI", f_ui), width=25)
        git_entry.grid(row=row, column=1, sticky="ew", pady=6, padx=(10, 5))

        def browse_git():
            path = filedialog.askopenfilename(
                title="SÃ©lectionner l'exÃ©cutable Git",
                filetypes=[("ExÃ©cutables", "*")]
            )
            if path:
                git_var.set(path)

        tk.Button(main_frame, text="ğŸ“‚", font=("Segoe UI", f_ui), command=browse_git).grid(
            row=row, column=2, pady=6)
        row += 1

        # Font zoom
        ttk.Label(main_frame, text="Font zoom:", font=("Segoe UI", f_ui)).grid(
            row=row, column=0, sticky="w", pady=6)
        zoom_var = tk.DoubleVar(value=self.global_settings.get("font_zoom", 1.6))
        zoom_spin = ttk.Spinbox(main_frame, textvariable=zoom_var, from_=0.5, to=3.0,
                                increment=0.1, font=("Segoe UI", f_ui), width=10)
        zoom_spin.grid(row=row, column=1, sticky="w", pady=6, padx=(10, 0))
        row += 1

        # Separator
        ttk.Separator(main_frame, orient="horizontal").grid(
            row=row, column=0, columnspan=3, sticky="ew", pady=10)
        row += 1

        # Auto-start polling
        auto_poll_var = tk.BooleanVar(value=self.global_settings.get("auto_start_polling", False))
        ttk.Checkbutton(main_frame, text="DÃ©marrer le polling automatiquement",
                       variable=auto_poll_var).grid(
            row=row, column=0, columnspan=3, sticky="w", pady=4)
        row += 1

        # Desktop notifications
        notif_var = tk.BooleanVar(value=self.global_settings.get("desktop_notifications", True))
        ttk.Checkbutton(main_frame, text="Notifications desktop (notify-send)",
                       variable=notif_var).grid(
            row=row, column=0, columnspan=3, sticky="w", pady=4)
        row += 1

        # Compact mode
        compact_var = tk.BooleanVar(value=self.global_settings.get("compact_mode", False))
        ttk.Checkbutton(main_frame, text="Mode compact (Ctrl+M pour basculer)",
                       variable=compact_var).grid(
            row=row, column=0, columnspan=3, sticky="w", pady=4)
        row += 1

        main_frame.columnconfigure(1, weight=1)

        # Buttons
        btn_frame = ttk.Frame(dialog)
        btn_frame.pack(fill="x", padx=15, pady=15)

        def save_settings():
            self.global_settings["git_binary"] = git_var.get().strip()
            self.global_settings["font_zoom"] = zoom_var.get()
            self.global_settings["auto_start_polling"] = auto_poll_var.get()
            self.global_settings["desktop_notifications"] = notif_var.get()
            self.global_settings["compact_mode"] = compact_var.get()

            try:
                save_global_settings(self.global_settings)
                messagebox.showinfo(
                    "Info",
                    "ParamÃ¨tres sauvegardÃ©s.\nRedÃ©marrez GitHerd pour appliquer le changement de zoom.",
                    parent=dialog
                )
            except Exception as e:
                messagebox.showerror("Erreur", f"Impossible de sauvegarder: {e}", parent=dialog)
                return

            dialog.destroy()

        tk.Button(btn_frame, text="Sauvegarder", font=("Segoe UI", f_ui),
                 command=save_settings).pack(side="left", padx=5)
        tk.Button(btn_frame, text="Annuler", font=("Segoe UI", f_ui),
                 command=dialog.destroy).pack(side="left", padx=5)

    # --------------------------------------------------------
    # REPOS MANAGEMENT
    # --------------------------------------------------------

    def load_saved_repos(self):
        """Charge les repos sauvegardÃ©s."""
        repos = load_saved_repos()
        git = self.global_settings.get("git_binary", "git")
        for repo_path in repos:
            if Path(repo_path).exists() and is_git_repo(repo_path, git):
                self.add_repo(repo_path)

    def save_current_repos(self):
        """Sauvegarde la liste des repos actuels."""
        repos = list(self.tabs.keys())
        save_repos(repos)

    def add_repo_dialog(self):
        """Ouvre un dialogue pour sÃ©lectionner un dÃ©pÃ´t Git."""
        path = filedialog.askdirectory(
            title="SÃ©lectionner un dÃ©pÃ´t Git",
            mustexist=True
        )
        if path:
            git = self.global_settings.get("git_binary", "git")
            if not is_git_repo(path, git):
                messagebox.showerror(
                    "Erreur",
                    f"'{path}' n'est pas un dÃ©pÃ´t Git valide.",
                    parent=self
                )
                return
            if path in self.tabs:
                messagebox.showinfo(
                    "Info",
                    f"Ce dÃ©pÃ´t est dÃ©jÃ  ouvert.",
                    parent=self
                )
                # SÃ©lectionner l'onglet existant
                self.notebook.select(self.tabs[path])
                return

            # DÃ©tecter les paramÃ¨tres du repo
            detected = detect_repo_settings(path, git)

            # VÃ©rifier si githerd.toml existe dÃ©jÃ 
            config_file = Path(path) / "githerd.toml"
            if not config_file.exists():
                # CrÃ©er le fichier avec les valeurs dÃ©tectÃ©es
                save_repo_config(path, detected)

            self.add_repo(path)
            self.save_current_repos()

    def add_repo(self, repo_path):
        """Ajoute un onglet pour un dÃ©pÃ´t."""
        tab = RepoTab(self.notebook.content, repo_path, self)
        repo_name = Path(repo_path).name
        tab.base_tab_name = repo_name  # Nom de base sans marqueur
        tab.has_update = False
        # Ajouter l'onglet (background gris par dÃ©faut)
        self.notebook.add(tab, text=repo_name)
        self.tabs[repo_path] = tab
        self.notebook.select(tab)
        self.after(100, self.update_repo_menu)
        self.after(150, self.update_title)

        # Auto-start polling si activÃ©
        if self.global_settings.get("auto_start_polling", False):
            self.after(500, tab.toggle_polling)

    def update_tab_name(self, tab):
        """Met Ã  jour le nom de l'onglet avec background colorÃ© et bullet si update."""
        if not hasattr(tab, 'base_tab_name'):
            return

        name = tab.base_tab_name
        bg_state = self.get_tab_bg_state(tab)

        # Bullet (â—) si mise Ã  jour dÃ©tectÃ©e
        if tab.has_update:
            self.notebook.tab(tab, text=f"â— {name}", bg_state=bg_state)
        else:
            self.notebook.tab(tab, text=name, bg_state=bg_state)

    def mark_tab_updated(self, tab):
        """Ajoute un marqueur Ã  l'onglet pour indiquer une mise Ã  jour."""
        if hasattr(tab, 'base_tab_name') and not tab.has_update:
            tab.has_update = True
            self.update_tab_name(tab)

    def clear_tab_marker(self, tab):
        """Efface le marqueur de mise Ã  jour de l'onglet."""
        if hasattr(tab, 'base_tab_name') and tab.has_update:
            tab.has_update = False
            self.update_tab_name(tab)

    def on_tab_changed(self, event):
        """AppelÃ© quand l'utilisateur change d'onglet."""
        try:
            tab = self.notebook.select()
            if tab:
                self.clear_tab_marker(tab)
                self.update_repo_menu()
        except tk.TclError:
            pass

    def update_repo_menu(self):
        """Met Ã  jour le menu Repo selon l'onglet actif."""
        self.repo_menu.delete(0, "end")

        tab = self.get_current_tab()
        if not tab:
            self.repo_menu.add_command(label="(aucun repo)", state="disabled")
            return

        # Configuration du repo
        self.repo_menu.add_command(
            label="Configuration...",
            command=tab.show_config_dialog
        )
        self.repo_menu.add_separator()

        # Actions
        self.repo_menu.add_command(
            label="Sync now",
            command=tab.manual_sync,
            state="normal" if tab.git_healthy else "disabled"
        )

        polling_label = "ArrÃªter polling" if tab.polling else "DÃ©marrer polling"
        self.repo_menu.add_command(
            label=polling_label,
            command=tab.toggle_polling,
            state="normal" if tab.git_healthy else "disabled"
        )

        self.repo_menu.add_separator()

        # Branches Ã  supprimer
        try:
            branches = get_tracked_branches(tab.remote, tab.prefix,
                                           cwd=tab.repo_path, git=tab.git)
        except:
            branches = []

        if branches:
            for b in branches:
                short_name = b.replace(f"{tab.remote}/", "")
                self.repo_menu.add_command(
                    label=f"Supprimer {short_name}",
                    command=lambda bn=short_name: tab.delete_branch(bn)
                )
            self.repo_menu.add_separator()

        # Utilitaires
        self.repo_menu.add_command(
            label="Exporter log...",
            command=tab.export_log
        )
        self.repo_menu.add_command(
            label="Ouvrir dossier",
            command=tab.open_folder
        )
        self.repo_menu.add_command(
            label="Test son",
            command=lambda: threading.Thread(target=play_beep, daemon=True).start()
        )

        self.repo_menu.add_separator()

        # Fermer l'onglet
        self.repo_menu.add_command(
            label="Fermer cet onglet",
            command=lambda: self.close_tab(tab)
        )

    def get_current_tab(self):
        """Retourne l'onglet actuellement sÃ©lectionnÃ©, ou None."""
        try:
            return self.notebook.select()
        except tk.TclError:
            pass
        return None

    # --------------------------------------------------------
    # TAB NAVIGATION
    # --------------------------------------------------------

    def next_tab(self):
        """Passe Ã  l'onglet suivant."""
        tabs = self.notebook.tabs()
        if len(tabs) < 2:
            return
        current = self.notebook.selected_index
        next_idx = (current + 1) % len(tabs)
        self.notebook.select(next_idx)

    def prev_tab(self):
        """Passe Ã  l'onglet prÃ©cÃ©dent."""
        tabs = self.notebook.tabs()
        if len(tabs) < 2:
            return
        current = self.notebook.selected_index
        prev_idx = (current - 1) % len(tabs)
        self.notebook.select(prev_idx)

    # --------------------------------------------------------
    # TITLE UPDATE
    # --------------------------------------------------------

    def update_title(self):
        """Met Ã  jour le titre avec le status."""
        total = len(self.tabs)
        polling = sum(1 for t in self.tabs.values() if t.polling)

        if total == 0:
            self.title("GitHerd")
        elif polling > 0:
            self.title(f"GitHerd â€” {total} repos, {polling} polling")
        else:
            self.title(f"GitHerd â€” {total} repos")

    # --------------------------------------------------------
    # COMPACT MODE
    # --------------------------------------------------------

    def toggle_compact_mode(self):
        """Bascule le mode compact."""
        compact = self.global_settings.get("compact_mode", False)
        self.global_settings["compact_mode"] = not compact
        save_global_settings(self.global_settings)

        # Appliquer Ã  tous les onglets
        for tab in self.tabs.values():
            tab.compact_mode = not compact
            if not compact:  # Passer en compact
                tab.buttons_frame.pack_forget()
                tab.log_header.pack_forget()
                tab.log_frame.pack_forget()
            else:  # Sortir du compact
                tab.buttons_frame.pack(fill="x", padx=10, pady=8)
                tab.log_header.pack(fill="x", padx=10, pady=(10, 0))
                if tab.log_visible:
                    tab.log_frame.pack(fill="both", expand=True, padx=10, pady=6)

    def is_any_action_active(self):
        """VÃ©rifie si une action est en cours dans un des onglets."""
        for tab in self.tabs.values():
            if tab.polling:
                return True
            if tab.lock.locked():
                return True
        return False

    def stop_all_polling(self):
        """ArrÃªte le polling sur tous les onglets."""
        stopped = 0
        for tab in self.tabs.values():
            if tab.polling:
                tab.polling = False
                tab.stop_countdown()
                tab.btn_poll.config(text="â–¶ Start polling")
                self.update_tab_name(tab)
                stopped += 1

        self.update_title()
        self.update_repo_menu()

        if stopped > 0:
            self.after(100, lambda: messagebox.showinfo(
                "Polling arrÃªtÃ©",
                f"{stopped} polling(s) arrÃªtÃ©(s).\nLes syncs en cours se termineront.",
                parent=self
            ))

    def restart_app(self):
        """RedÃ©marre l'application, avec confirmation si polling en cours."""
        # VÃ©rifier si une sync est en cours (lock)
        any_sync_locked = any(tab.lock.locked() for tab in self.tabs.values())
        if any_sync_locked:
            messagebox.showwarning(
                "Sync en cours",
                "Impossible de redÃ©marrer : une synchronisation est en cours.\n"
                "Attendez la fin de la sync.",
                parent=self
            )
            return

        # VÃ©rifier si des polling sont actifs
        polling_count = sum(1 for tab in self.tabs.values() if tab.polling)
        if polling_count > 0:
            result = messagebox.askyesno(
                "Polling en cours",
                f"{polling_count} polling(s) actif(s).\n\n"
                "ArrÃªter les polling et redÃ©marrer ?",
                parent=self
            )
            if not result:
                return  # Cancel

            # ArrÃªter tous les polling silencieusement
            for tab in self.tabs.values():
                if tab.polling:
                    tab.polling = False
                    tab.stop_countdown()

        # Sauvegarder l'Ã©tat
        self.save_current_repos()

        # RedÃ©marrer
        python = sys.executable
        script = os.path.abspath(__file__)
        self.destroy()
        os.execl(python, python, script)

    def on_tab_right_click(self, event):
        """GÃ¨re le clic droit sur un onglet."""
        try:
            # RÃ©cupÃ©rer l'index depuis l'Ã©vÃ©nement CustomNotebook
            if hasattr(event, 'tab_index'):
                index = event.tab_index
            else:
                index = self.notebook.index(f"@{event.x},{event.y}")

            tabs_list = self.notebook.tabs()
            if index < len(tabs_list):
                tab = tabs_list[index]

                f_ui = int(11 * self.font_zoom)
                menu = tk.Menu(self, tearoff=0, font=("Segoe UI", f_ui))
                menu.add_command(
                    label="âŒ Fermer cet onglet",
                    command=lambda: self.close_tab(tab)
                )
                menu.tk_popup(event.x, event.y)
        except (tk.TclError, IndexError):
            pass

    def close_tab(self, tab):
        """Ferme un onglet."""
        # Trouver le repo_path correspondant
        repo_path = None
        for path, t in self.tabs.items():
            if t == tab:
                repo_path = path
                break

        if repo_path:
            # ArrÃªter le polling et countdown
            tab.polling = False
            tab.stop_countdown()

            # Supprimer de la liste
            del self.tabs[repo_path]

            # Supprimer l'onglet
            self.notebook.forget(tab)

            # Sauvegarder et mettre Ã  jour
            self.save_current_repos()
            self.update_title()
            self.update_repo_menu()

    def show_help(self):
        f_ui = int(11 * self.font_zoom)
        f_log = int(11 * self.font_zoom)

        help_win = tk.Toplevel(self)
        help_win.title("Aide â€” GitHerd")
        help_win.geometry(f"{int(650 * self.font_zoom)}x{int(600 * self.font_zoom)}")
        help_win.transient(self)
        help_win.grab_set()

        text = ScrolledText(help_win, font=("Consolas", f_log), wrap="word")
        text.pack(fill="both", expand=True, padx=10, pady=10)
        text.insert("1.0", HELP_TEXT)
        text.configure(state="disabled")

        tk.Button(
            help_win, text="Fermer", font=("Segoe UI", f_ui),
            command=help_win.destroy
        ).pack(pady=10)

    def on_close(self):
        """AppelÃ© Ã  la fermeture de l'application."""
        # ArrÃªter tous les pollings
        for tab in self.tabs.values():
            tab.polling = False

        # Sauvegarder
        self.save_current_repos()

        # Fermer
        self.destroy()


# ============================================================

if __name__ == "__main__":
    App().mainloop()
